import{_ as s,o as n,c as a,a as e}from"./app-e5ba6616.js";const i="/home/assets/ln-976a7e59.png",l={},c=e(`<h2 id="bash进阶" tabindex="-1"><a class="header-anchor" href="#bash进阶" aria-hidden="true">#</a> Bash进阶</h2><h2 id="bash登陆环境" tabindex="-1"><a class="header-anchor" href="#bash登陆环境" aria-hidden="true">#</a> bash登陆环境</h2><p>用户每次使用 Shell，都会开启一个与 Shell 的 Session（对话）。</p><p>Session 有两种类型：登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p><p>这里针对的是linux，在mac上不太一样，mac上都没有/etc/profile.d这个文件夹</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> /etc/profile 
<span class="token comment"># System-wide .profile for sh(1)</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-x</span> /usr/libexec/path_helper <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token builtin class-name">eval</span> <span class="token variable"><span class="token variable">\`</span>/usr/libexec/path_helper <span class="token parameter variable">-s</span><span class="token variable">\`</span></span>
<span class="token keyword">fi</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">\${<span class="token environment constant">BASH</span>-no}</span>&quot;</span> <span class="token operator">!=</span> <span class="token string">&quot;no&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
	<span class="token punctuation">[</span> <span class="token parameter variable">-r</span> /etc/bashrc <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">.</span> /etc/bashrc
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="登录-session" tabindex="-1"><a class="header-anchor" href="#登录-session" aria-hidden="true">#</a> 登录 Session</h3><p><strong>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session</strong>，通常需要用户输入用户名和密码进行登录。</p><p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p><ul><li><code>/etc/profile</code>：所有用户的全局配置脚本。</li><li><code>/etc/profile.d</code>目录里面所有<code>.sh</code>文件</li><li><code>~/.bash_profile</code>：用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li><li><code>~/.bash_login</code>：如果<code>~/.bash_profile</code>没找到，则尝试执行这个脚本（C shell 的初始化脚本）。如果该脚本存在，则执行完就不再往下执行。</li><li><code>~/.profile</code>：如果<code>~/.bash_profile</code>和<code>~/.bash_login</code>都没找到，则尝试读取这个脚本（Bourne shell 和 Korn shell 的初始化脚本）。</li></ul><p>Linux 发行版更新的时候，会更新<code>/etc</code>里面的文件，比如<code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在<code>/etc/profile.d</code>目录里面新建<code>.sh</code>脚本。</p><p>如果想修改你个人的登录环境，一般是写在<code>~/.bash_profile</code>里面。下面是一个典型的<code>.bash_profile</code>文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># .bash_profile</span>
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token environment constant">$HOME</span>/bin
<span class="token assign-left variable"><span class="token environment constant">SHELL</span></span><span class="token operator">=</span>/bin/bash
<span class="token assign-left variable">MANPATH</span><span class="token operator">=</span>/usr/man:/usr/X11/man
<span class="token assign-left variable">EDITOR</span><span class="token operator">=</span>/usr/bin/vi
<span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">&#39;\\h:\\w\\$ &#39;</span>
<span class="token assign-left variable"><span class="token environment constant">PS2</span></span><span class="token operator">=</span><span class="token string">&#39;&gt; &#39;</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> ~/.bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
<span class="token builtin class-name">.</span> ~/.bashrc
<span class="token keyword">fi</span>
<span class="token builtin class-name">export</span> <span class="token environment constant">PATH</span>
<span class="token builtin class-name">export</span> EDITOR
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了<code>~/.bashrc</code>。</p><p><code>bash</code>命令的<code>--login</code>参数，会强制执行登录 Session 会执行的脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">bash</span> <span class="token parameter variable">--login</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>bash</code>命令的<code>--noprofile</code>参数，会跳过上面这些 Profile 脚本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">bash</span> <span class="token parameter variable">--noprofile</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="非登录-session" tabindex="-1"><a class="header-anchor" href="#非登录-session" aria-hidden="true">#</a> 非登录 Session</h3><p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行<code>bash</code>命令，就会新建一个非登录 Session。</p><p>非登录 Session 的初始化脚本依次如下。</p><ul><li><code>/etc/bash.bashrc</code>：对全体用户有效。</li><li><code>~/.bashrc</code>：仅对当前用户有效。</li></ul><p>对用户来说，<code>~/.bashrc</code>通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以<code>~/.bashrc</code>也是每次执行脚本都会执行的。</p><p><code>bash</code>命令的<code>--norc</code>参数，可以禁止在非登录 Session 执行<code>~/.bashrc</code>脚本。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ bash --norc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>bash</code>命令的<code>--rcfile</code>参数，指定另一个脚本代替<code>.bashrc</code>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ bash --rcfile testrc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>.bash_logout</strong></p><p><code>~/.bash_logout</code>脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p><p>如果没有退出时要执行的命令，这个文件也可以不存在。</p><p><strong>启动选项</strong></p><p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p><ul><li><code>-n</code>：不运行脚本，只检查是否有语法错误。</li><li><code>-v</code>：输出每一行语句运行结果前，会先输出该行语句。</li><li><code>-x</code>：每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li></ul><p><strong>键盘绑定</strong></p><p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为<code>/etc/inputrc</code>，你可以在主目录创建自己的键盘绑定文件<code>.inputrc</code>文件。</p><h2 id="命令提示符" tabindex="-1"><a class="header-anchor" href="#命令提示符" aria-hidden="true">#</a> 命令提示符</h2><p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p><h3 id="环境变量-ps1" tabindex="-1"><a class="header-anchor" href="#环境变量-ps1" aria-hidden="true">#</a> 环境变量 PS1</h3><p>命令提示符通常是美元符号<code>$</code>，对于根用户则是井号<code>#</code>。这个符号是环境变量<code>PS1</code>决定的，执行下面的命令，可以看到当前命令提示符的定义。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash-3.2$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PS1</span>
<span class="token punctuation">\\</span>s-<span class="token punctuation">\\</span>v<span class="token punctuation">\\</span>$
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后的<code>PS1</code>，可以放在用户的 Bash 配置文件<code>.bashrc</code>里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ source ~/.bashrc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p><ul><li><code>\\a</code>：响铃，计算机发出一记声音。</li><li><code>\\d</code>：以星期、月、日格式表示当前日期，例如“Mon May 26”。</li><li><strong><code>\\h</code>：本机的主机名。</strong></li><li><code>\\H</code>：完整的主机名。</li><li><code>\\j</code>：运行在当前 Shell 会话的工作数。</li><li><code>\\l</code>：当前终端设备名。</li><li><code>\\n</code>：一个换行符。</li><li><code>\\r</code>：一个回车符。</li><li><code>\\s</code>：Shell 的名称。</li><li><code>\\t</code>：24小时制的<code>hours:minutes:seconds</code>格式表示当前时间。</li><li><code>\\T</code>：12小时制的当前时间。</li><li><code>\\@</code>：12小时制的<code>AM/PM</code>格式表示当前时间。</li><li><code>\\A</code>：24小时制的<code>hours:minutes</code>表示当前时间。</li><li><strong><code>\\u</code>：当前用户名。</strong></li><li><code>\\v</code>：Shell 的版本号。</li><li><code>\\V</code>：Shell 的版本号和发布号。</li><li><strong><code>\\w</code>：当前的工作路径。</strong></li><li><strong><code>\\W</code>：当前目录名。</strong></li><li><code>\\!</code>：当前命令在命令历史中的编号。</li><li><code>\\#</code>：当前 shell 会话中的命令数。</li><li><strong><code>\\$</code>：普通用户显示为<code>$</code>字符，根用户显示为<code>#</code>字符。</strong></li><li><code>\\[</code>：非打印字符序列的开始标志。</li><li><code>\\]</code>：非打印字符序列的结束标志。</li></ul><p>举例来说，<code>[\\u@\\h \\W]\\$</code>这个提示符定义，显示出来就是<code>[user@host ~]$</code>（具体的显示内容取决于你的系统）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>user@host ~<span class="token punctuation">]</span>$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PS1</span>
<span class="token punctuation">[</span><span class="token punctuation">\\</span>u@<span class="token punctuation">\\</span>h <span class="token punctuation">\\</span>W<span class="token punctuation">]</span><span class="token punctuation">\\</span>$
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>颜色</strong></p><p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p><p>使用下面的代码，可以设定其后文本的颜色。</p><ul><li><code>\\033[0;30m</code>：黑色</li><li><code>\\033[1;30m</code>：深灰色</li><li><strong><code>\\033[0;31m</code>：红色</strong></li><li><code>\\033[1;31m</code>：浅红色</li><li><strong><code>\\033[0;32m</code>：绿色</strong></li><li><code>\\033[1;32m</code>：浅绿色</li><li><code>\\033[0;33m</code>：棕色</li><li><code>\\033[1;33m</code>：黄色</li><li><code>\\033[0;34m</code>：蓝色</li><li><code>\\033[1;34m</code>：浅蓝色</li><li><code>\\033[0;35m</code>：粉红</li><li><code>\\033[1;35m</code>：浅粉色</li><li><code>\\033[0;36m</code>：青色</li><li><code>\\033[1;36m</code>：浅青色</li><li><code>\\033[0;37m</code>：浅灰色</li><li><code>\\033[1;37m</code>：白色</li></ul><p>举例来说，如果要将提示符设为红色，可以将<code>PS1</code>设成下面的代码。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>PS1=&#39;\\[\\033[0;31m\\]&lt;\\u@\\h \\W&gt;\\$&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码<code>\\[\\033[00m\\]</code>，表示将其后的文本恢复到默认颜色。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>PS1=&#39;\\[\\033[0;31m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[00m\\]&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p><ul><li><code>\\033[0;40m</code>：蓝色</li><li><code>\\033[1;44m</code>：黑色</li><li><code>\\033[0;41m</code>：红色</li><li><code>\\033[1;45m</code>：粉红</li><li><code>\\033[0;42m</code>：绿色</li><li><code>\\033[1;46m</code>：青色</li><li><code>\\033[0;43m</code>：棕色</li><li><code>\\033[1;47m</code>：浅灰色</li></ul><p>下面是一个带有红色背景的提示符。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>PS1=&#39;\\[\\033[0;41m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[0m\\] &#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="ps2-ps3-ps4" tabindex="-1"><a class="header-anchor" href="#ps2-ps3-ps4" aria-hidden="true">#</a> PS2,PS3,PS4</h3><p>除了<code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p><p>环境变量<code>PS2</code>是命令行折行输入时系统的提示符，默认为<code>&gt;</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@ls  ~  <span class="token builtin class-name">echo</span> <span class="token string">&quot;e      
dquote&gt; 
dquote&gt; d            
dquote&gt; 
dquote&gt; &quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>环境变量<code>PS3</code>是使用<code>select</code>命令时，系统输入菜单的提示符：<code>#?</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~/Documents/GoWorkspace/src/MyLearn/sh  ./geth.sh                                                 
Which environment <span class="token keyword">do</span> you want to start your geth on?
<span class="token number">1</span><span class="token punctuation">)</span> bsc-prod-primary  <span class="token number">3</span><span class="token punctuation">)</span> eth-prod-primary  <span class="token number">5</span><span class="token punctuation">)</span> bsc-dev
<span class="token number">2</span><span class="token punctuation">)</span> bsc-prod-backup   <span class="token number">4</span><span class="token punctuation">)</span> eth-prod-backup   <span class="token number">6</span><span class="token punctuation">)</span> eth-dev
<span class="token comment">#? 7</span>
Invalid environment.

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>环境变量<code>PS4</code>默认为<code>+</code>。它是使用 Bash 的<code>-x</code>参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p><h2 id="归档和备份" tabindex="-1"><a class="header-anchor" href="#归档和备份" aria-hidden="true">#</a> 归档和备份</h2><h3 id="gzip" tabindex="-1"><a class="header-anchor" href="#gzip" aria-hidden="true">#</a> gzip</h3><p>gzip 程序用来压缩文件，原文件的压缩版（添加<code>gz</code>后缀名）<strong>会替代原文件</strong>。gunzip 程序用来还原压缩版本。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ gzip test.txt
$ gunzip test.txt.gz
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>gzip</code>的参数如下。</p><ul><li>-c 把输出写入到标准输出，并且保留原始文件。也有可能用 -stdout 和 -to-stdout 选项来指定。</li><li>-d 解压缩。正如 gunzip 命令一样。也可以用 -decompress 或者 -uncompress 选项来指定.</li><li>-f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用 -force 选项来指定。</li><li>-h 显示用法信息。也可用 -help 选项来指定。</li><li>-l 列出每个被压缩文件的压缩数据。也可用 -list 选项。</li><li>-r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用 -recursive 选项来指定。</li><li>-t 测试压缩文件的完整性。也可用 -test 选项来指定。</li><li>-v 显示压缩过程中的信息。也可用 -verbose 选项来指定。</li><li>-number 设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用 -fast 和 -best 选项来表示。默认值是整数6。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看解压缩后的内容</span>
gunzip <span class="token parameter variable">-c</span> test.txt.gz <span class="token operator">|</span> <span class="token function">less</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bzip2" tabindex="-1"><a class="header-anchor" href="#bzip2" aria-hidden="true">#</a> bzip2</h3><p><code>bzip2</code>程序与<code>gzip</code>程序相似，但是使用了不同的压缩算法，舍弃了压缩速度，实现了更高的压缩级别。在大多数情况下，它的工作模式等同于<code>gzip</code>。 由<code>bzip2</code>压缩的文件，用扩展名<code>.bz2</code>表示。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">bzip2</span> foo.txt
$ bunzip2 foo.txt.bz2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>gzip程序的所有选项（除了<code>-r</code>），bzip2 程序同样也支持。同样有 bunzip2 和 bzcat 程序来解压缩文件。bzip2 文件也带有 bzip2recover 程序，其会 试图恢复受损的 .bz2 文件。</p><h3 id="zip" tabindex="-1"><a class="header-anchor" href="#zip" aria-hidden="true">#</a> zip</h3><p><code>zip</code>程序既是压缩工具，也是一个打包工具，读取和写入.zip文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">zip</span> options zipfile file<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的用法如下。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将指定目录压缩成zip文件</span>
$ <span class="token function">zip</span> <span class="token parameter variable">-r</span> playground.zip playground
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>zip</code>与<code>tar</code>命令有一个相反之处。如果压缩文件已存在，其将被更新而不是被替代。这意味着会保留此文件包，但是会添加新文件，同时替换匹配的文件。</p><p>解压使用<code>unzip</code>命令。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ unzip ../playground.zip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>unzip</code>命令的参数如下。</p><ul><li><code>-l</code> 列出文件包中的内容而不解压</li><li><code>-v</code> 显示冗余信息</li><li><code>-p</code> 输出发送到标准输出</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">unzip</span> <span class="token parameter variable">-p</span> ls-etc.zip <span class="token operator">|</span> <span class="token function">less</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="tar" tabindex="-1"><a class="header-anchor" href="#tar" aria-hidden="true">#</a> tar</h3><p><code>tar</code>是tape archive的简称，原来是一款制作磁带备份的工具，现在主要用于打包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。</p><p><code>tar</code>程序的语法如下。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">tar</span> mode<span class="token punctuation">[</span>options<span class="token punctuation">]</span> pathname<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>tar支持以下模式。</p><ul><li>c 表示create，为文件和／或目录列表创建归档文件。</li><li>x 抽取归档文件。</li><li>r 追加具体的路径到归档文件的末尾。</li><li>t 列出归档文件的内容。</li></ul><p>支持的参数如下。</p><ul><li>f 表示file，用来指定生成的文件。</li></ul><p>模式和参数可以写在一起，而且不需要开头的短横线。注意，必须首先指定模式，然后才是其它的选项。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建子目录的tar包</span>
$ <span class="token function">tar</span> cf playground.tar playground
<span class="token comment"># 查看tar包内容</span>
$ <span class="token function">tar</span> tf playground.tar
<span class="token comment"># 查看更详细的列表信息</span>
$ <span class="token function">tar</span> tvf playground.tar
<span class="token comment"># 还原归档文件</span>
$ <span class="token function">tar</span> xf playground.tar
<span class="token comment"># 还原单个文件</span>
$ <span class="token function">tar</span> xf archive.tar pathname
<span class="token comment"># 还原文件到指定目录</span>
$ <span class="token function">tar</span> xvf archive.tar <span class="token parameter variable">-C</span> /home/me/
<span class="token comment"># 追加文件</span>
$ <span class="token function">tar</span> rf archive.tar file.txt
<span class="token comment"># 验证归档文件内容是否正确</span>
$ <span class="token function">tar</span> tvfW archive.tar
<span class="token comment"># 支持通配符</span>
$ <span class="token function">tar</span> xf <span class="token punctuation">..</span>/playground2.tar <span class="token parameter variable">--wildcards</span> <span class="token string">&#39;home/me/playground/\\*.txt&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>tar</code>命令还原的时候，总是还原为相对路径。如果归档的时候，保存的是绝对路径，那么还原的时候，这个绝对路径会整个变成相对路径。</p><p><code>find</code>命令可以与<code>tar</code>命令配合使用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">find</span> playground <span class="token parameter variable">-name</span> <span class="token string">&#39;file.txt&#39;</span> <span class="token parameter variable">-exec</span> <span class="token function">tar</span> rf playground.tar <span class="token string">&#39;{}&#39;</span> <span class="token string">&#39;+&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令先用<code>find</code>程序找到所有名为<code>file.txt</code>的文件，然后使用追加模式（<code>r</code>）的<code>tar</code>命令，把匹配的文件添加到归档文件<code>playground.tar</code>里面。</p><p>这种<code>tar</code>和<code>find</code>的配合使用，可以创建逐渐增加的目录树或者整个系统的备份。通过<code>find</code>命令匹配新于某个时间戳的文件，我们就能够创建一个归档文件，其只包含新于上一个 tar 包的文件。</p><p>tar支持压缩功能。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 打成gzip压缩包</span>
$ <span class="token function">tar</span> czvf assets.tar.gz dist
<span class="token comment"># 打成bz2压缩包</span>
$ <span class="token function">tar</span> cvfj assets.tar.bz2 dist
<span class="token comment"># 解压 tar.gz 文件</span>
$ <span class="token function">tar</span> xzv archive.tar.gz
$ <span class="token function">tar</span> xvf archive.tar.gz
<span class="token comment"># 解压bz2压缩包</span>
$ <span class="token function">tar</span> xvf archive.tar.bz2
<span class="token comment"># 显示gzip压缩包内容</span>
$ <span class="token function">tar</span> tvf archive.tar.gz
<span class="token comment"># 显示bz2压缩包内容</span>
$ <span class="token function">tar</span> tvf archive.tar.bz2
<span class="token comment"># 从gzip压缩包取出单个文件</span>
$ <span class="token function">tar</span> zxvf archive.tar.gz file.txt
<span class="token comment"># 从bz2压缩包取出单个文件</span>
$ <span class="token function">tar</span> jxvf archive.tar.bz2 file.txt
<span class="token comment"># 按通配符取出文件</span>
$ <span class="token function">tar</span> zxvf archive.tar.gz <span class="token parameter variable">--wildcards</span> <span class="token string">&#39;*.php&#39;</span>
$ <span class="token function">tar</span> jxvf archive.tar.bz2 <span class="token parameter variable">--wildcards</span> <span class="token string">&#39;*.php&#39;</span>
<span class="token comment"># 追加文件到压缩包</span>
$ <span class="token function">tar</span> rvf archive.tar.gz xyz.txt
$ <span class="token function">tar</span> rvf archive.tar.bz2 xyz.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="异步任务" tabindex="-1"><a class="header-anchor" href="#异步任务" aria-hidden="true">#</a> 异步任务</h2><p>Bash脚本有时候需要同时执行多个任务。通常这涉及到启动一个脚本，依次，启动一个或多个子脚本来执行额外的任务，而父脚本继续运行。然而，当一系列脚本 以这种方式运行时，要保持父子脚本之间协调工作，会有一些问题。也就是说，若父脚本或子脚本依赖于另一方，并且 一个脚本必须等待另一个脚本结束任务之后，才能完成它自己的任务，这应该怎么办？</p><p>bash 有一个内置命令，能帮助管理诸如此类的异步执行的任务。wait 命令导致一个父脚本暂停运行，直到一个 特定的进程（例如，子脚本）运行结束。</p><p>首先我们将演示一下 wait 命令的用法。为此，我们需要两个脚本，一个父脚本：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># async-parent : Asynchronous execution demo (parent)</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: starting...&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: launching child script...&quot;</span>
<span class="token builtin class-name">source</span> ./sync_c.sh <span class="token operator">&amp;</span>
<span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token variable">$!</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: child (PID= <span class="token variable">$pid</span>) launched.&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: continuing...&quot;</span>
<span class="token function">sleep</span> <span class="token number">2</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: pausing to wait for child to finish...&quot;</span>
<span class="token function">wait</span> <span class="token variable">$pid</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: child is finished. Continuing...&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Parent: parent is done. Exiting.&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和一个子脚本：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># async-child : Asynchronous execution demo (child)</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Child: child is running...&quot;</span>
<span class="token function">sleep</span> <span class="token number">5</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Child: child is done. Exiting.&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们看到该子脚本是非常简单的。真正的操作通过父脚本完成。在父脚本中，子脚本被启动， 并被放置到后台运行。子脚本的进程 ID 记录在 pid 变量中，这个变量的值是 $! shell 参数的值，它总是 包含放到后台执行的最后一个任务的进程 ID 号。</p><p>父脚本继续，然后执行一个以子进程 PID 为参数的 wait 命令。这就导致父脚本暂停运行，直到子脚本退出， 意味着父脚本结束。</p><p>当执行后，父子脚本产生如下输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Parent: starting...
Parent: launching child script...
Parent: child (PID= 48310) launched.
Parent: continuing...
Child: child is running...
Parent: pausing to wait for child to finish...
Child: child is done. Exiting.
Parent: child is finished. Continuing...
Parent: parent is done. Exiting.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="文件操作" tabindex="-1"><a class="header-anchor" href="#文件操作" aria-hidden="true">#</a> 文件操作</h2><h3 id="cp" tabindex="-1"><a class="header-anchor" href="#cp" aria-hidden="true">#</a> CP</h3><p><code>cp</code>命令用于将文件（或目录）拷贝到目的地。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 拷贝单个文件</span>
$ <span class="token function">cp</span> <span class="token builtin class-name">source</span> dest
<span class="token comment"># 拷贝多个文件</span>
$ <span class="token function">cp</span> source1 source2 source3 dest
<span class="token comment"># -i 目的地有同名文件时会提示确认</span>
$ <span class="token function">cp</span> <span class="token parameter variable">-i</span> file1 file2
<span class="token comment"># -r 递归拷贝，将dir1拷贝到dir2，完成后dir2生成一个子目录dir1</span>
<span class="token comment"># dir2如果不存在，将被创建</span>
<span class="token comment"># 拷贝目录时，该参数是必需的</span>
$ <span class="token function">cp</span> <span class="token parameter variable">-r</span> dir1 dir2
<span class="token comment"># -u --update 只拷贝目的地没有的文件，或者比目的地同名文件更新的文件</span>
$ <span class="token function">cp</span> <span class="token parameter variable">-u</span> *.html destination
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他参数</p><ul><li><code>-a</code> 拷贝时保留所有属性，包括所有者与权限</li><li><code>-v</code> 显示拷贝的详细信息</li></ul><h3 id="mv" tabindex="-1"><a class="header-anchor" href="#mv" aria-hidden="true">#</a> mv</h3><p><code>mv</code>命令用于将源文件移动到目的地。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 移动单个文件</span>
$ <span class="token function">mv</span> item1 item2
<span class="token comment"># 移动多个文件</span>
$ <span class="token function">mv</span> file1 file2 dir1
<span class="token comment"># 将dir1拷贝进入dir2，完成后dir2将多出一个子目录dir1</span>
<span class="token comment"># 如果dir2不存在，将会被创建</span>
$ <span class="token function">mv</span> dir1 dir2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数</p><ul><li><code>-i</code> 覆盖已经存在的文件时，会提示确认</li><li><code>-u</code> 只移动目的地不存在的文件，或比目的地更新的文件</li></ul><h3 id="rm" tabindex="-1"><a class="header-anchor" href="#rm" aria-hidden="true">#</a> rm</h3><p><code>rm</code>命令用于删除文件。</p><p>参数。</p><ul><li><code>-i</code> 文件存在时，会提示确认。</li><li><code>-r</code> 递归删除一个子目录</li><li><code>-f</code> 如果删除不存在的文件，不报错</li><li><code>-v</code> 删除时展示详细信息</li></ul><h3 id="ln" tabindex="-1"><a class="header-anchor" href="#ln" aria-hidden="true">#</a> ln</h3><p><code>ln</code>命令用于建立链接文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 新建硬链接</span>
$ <span class="token function">ln</span> <span class="token function">file</span> <span class="token function">link</span>
<span class="token comment"># 新建软链接</span>
$ <span class="token function">ln</span> <span class="token parameter variable">-s</span> item <span class="token function">link</span>
参数：
	<span class="token parameter variable">-i</span> 交互模式。
	<span class="token parameter variable">-s</span> 软链接<span class="token punctuation">(</span>符号链接<span class="token punctuation">)</span>。如果不加 “-s” 选项，则建立硬链接文件
	<span class="token parameter variable">-d</span> 允许超级用户制作目录的硬链接。
	<span class="token parameter variable">-b</span> 删除，覆盖以前建立的链接
	<span class="token parameter variable">-f</span> 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）软链接 软链接是Linux中常用的命令，它的功能是某一文件在另外一个位置建立一个同步的链接，相当于C语言中的指针，建立的链接直接指向源文件所在的地址，软链接不会另外占用资源，当同一文件需要在多个位置被用到的时候，就会使用到软连接。</p><p>（2）硬链接 硬链接在是另外一个位置创建源文件的链接文件，相当于复制了一份，占用资源会倍增。硬链接一旦创建，源文件和链接文件任何一方修改文件都会同步修改。</p><img src="`+i+`" alt="screenshot2024-10-20 10.09.57" style="zoom:33%;"><h2 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统" aria-hidden="true">#</a> 文件系统</h2><h3 id="ls" tabindex="-1"><a class="header-anchor" href="#ls" aria-hidden="true">#</a> ls</h3><p><code>ls</code>目录可以显示指定目录的内容。不加参数时，显示当前目录的内容。<code>ls</code>命令也可以显示指定文件是否存在。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> foo.txt
foo.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-l</code>参数可以显示文件的详细信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> test.txt                                                       
-rw-r--r--  <span class="token number">1</span> liushun  staff  <span class="token number">13</span>  <span class="token number">9</span>  <span class="token number">6</span> <span class="token number">13</span>:27 test.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令输出结果的第一栏，是文件的类型和权限。</p><p>文件类型分为以下几种。</p><ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录</li><li><code>l</code> 符号链接。注意，对于符号链接文件，剩余的文件属性总是”rwxrwxrwx”。</li><li><code>c</code> 字符设备文件，指按照字节流处理数据的设备，比如调制解调器。</li><li><code>b</code> 块设备文件，指按照数据块处理数据的设备，比如硬盘。</li></ul><p>其他参数的用法。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示多个目录的内容</span>
$ <span class="token function">ls</span> ~ /usr
<span class="token comment"># -a --all 显示隐藏文件</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-a</span>
<span class="token comment"># -A 与-a类似，但是不显示当前目录和上一级目录两个点文件</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-A</span>
<span class="token comment"># -l 显示详细信息</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span>
<span class="token comment"># -1 单列显示，每行只显示一个文件，只展示一个名字</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-1</span>
<span class="token comment"># -d 显示当前目录本身，而不是它的内容</span>
<span class="token comment"># 通常与-l配合使用，列出一个目录本身的详细信息</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-dl</span> <span class="token comment"># drwx------+ 16 liushun  staff  512 10 20 10:14 .</span>
<span class="token comment"># -F 目录名之后添加斜杠，可执行文件后面添加星号</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-F</span>
<span class="token comment"># -h 与-l配合使用，将文件大小显示为人类可读的格式</span>
<span class="token comment"># -t 按文件修改时间排序，修改晚的排在前面</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-t</span>
<span class="token comment"># -s 按文件大小排序，</span>
<span class="token comment"># --reverse 显示结果倒序排列</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-lt</span> <span class="token parameter variable">--reverse</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="stat" tabindex="-1"><a class="header-anchor" href="#stat" aria-hidden="true">#</a> stat</h3><p><code>stat</code>命令是加强版的<code>ls</code>命令，可以显示一个文件的详细信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>tat test.txt             
<span class="token number">16777231</span> <span class="token number">18289095</span> -rw-r--r-- <span class="token number">1</span> liushun staff <span class="token number">0</span> <span class="token number">13</span> <span class="token string">&quot;Oct 20 10:14:52 2024&quot;</span> <span class="token string">&quot;Sep  6 13:27:02 2024&quot;</span> <span class="token string">&quot;Oct 20 10:14:51 2024&quot;</span> <span class="token string">&quot;Sep  6 13:27:02 2024&quot;</span> <span class="token number">4096</span> <span class="token number">8</span> <span class="token number">0</span> test.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="touch" tabindex="-1"><a class="header-anchor" href="#touch" aria-hidden="true">#</a> touch</h3><p><code>touch</code>用来设置或更新文件的访问，更改，和修改时间。然而，如果一个文件名参数是一个不存在的文件，则会创建一个空文件。</p><p>如果该文件已经存在，就会把它的修改时间设置为当前时间。</p><h3 id="file" tabindex="-1"><a class="header-anchor" href="#file" aria-hidden="true">#</a> file</h3><p><code>file</code>命令显示指定文件的类型。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">file</span> test.txt 
test.txt: ASCII text
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="chmod" tabindex="-1"><a class="header-anchor" href="#chmod" aria-hidden="true">#</a> chmod</h3><p><code>chmod</code>命令用于更改文件的权限，是“change mode”的缩写。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ chmod 600 foo.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>chmod</code>还可以接受四个缩写，为不同的对象单独设置权限。</p><ul><li><code>u</code> 所有者“user”的简写</li><li><code>g</code> 用户组“group”的缩写</li><li><code>o</code> 其他所有人“others”的简写</li><li><code>a</code> 所有人“all”的简写</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 为所有者添加可执行权限</span>
$ <span class="token function">chmod</span> u+x foo.txt
<span class="token comment"># 删除所有者的可执行权限</span>
$ <span class="token function">chmod</span> u-x foo.txt
<span class="token comment"># 为所有人添加可执行权限，等价于 a+x</span>
$ <span class="token function">chmod</span> +x foo.txt
<span class="token comment"># 删除其他人的读权限和写权限。</span>
$ <span class="token function">chmod</span> o-rw foo.txt
<span class="token comment"># 设定用户组和其他人的权限是读权限和写权限</span>
$ <span class="token function">chmod</span> <span class="token assign-left variable">go</span><span class="token operator">=</span>rw foo.txt
<span class="token comment"># 为所有者添加执行权限，设定用户组和其他人为读权限和写权限，多种设定用逗号分隔</span>
$ <span class="token function">chmod</span> u+x,go<span class="token operator">=</span>rw foo.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>添加权限。</p><ul><li>+x 添加执行权限</li><li>+r 设置读权限</li><li>+w 设置写权限</li><li>+rwx 设置所有读、写和执行权限。</li></ul><p>删除权限只需将<code>+</code>更改为<code>-</code>，就可以删除任何已设置的指定权限。可以使用<code>-R</code>（或<code>--recursive</code>）选项来递归地操作目录和文件。</p><p>设置精确权限，可以使用<code>=</code>代替<code>+</code>或<code>-</code>来实现此操作。如果想为用户、组或其他用户设置不同的权限，可以使用逗号将不同表达式分开（例如<code>ug=rwx,o=rx</code>）。</p><p>由于一共有3种可能的权限。也可以使用八进制数代替符号来设置权限。通过这种方式设置的权限最多使用3个八进制数。第1个数定义用户权限，第2个数定义组权限，第3个数定义其他权限。这3个数中的每一个都通过添加想要的权限设置来构造：读 (4)、写 (2) 和执行 (1)。</p><p>比如600，就表示用户具有读写权限，组和其他没有权限。</p><h3 id="umask" tabindex="-1"><a class="header-anchor" href="#umask" aria-hidden="true">#</a> umask</h3><p><code>umask</code>用来查看和设置权限掩码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">umask</span>
022
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>命令显示当前系统之中，默认的文件掩码是<code>022</code>，转为二进制就是<code>000 010 010</code>。9位分别代表文件三种使用对象的三类权限。只要对应位置上是<code>1</code>，就表示关闭该项权限，所以<code>010</code>就表示关闭读权限。</p><p>新建文件时，通常不会带有执行权限，也就是说，新建文件的默认权限是<code>rw-rw-rw-</code>。如果文件掩码是<code>0022</code>，那么用户组和其他人的写权限也会被拿掉。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> test.txt 
-rw-r--r--  <span class="token number">1</span> liushun  staff  <span class="token number">13</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">10</span>:24 test.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>umask</code>后面跟着参数，就表示设置权限掩码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">umask</span> 0000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令将权限掩码设为<code>0000</code>，实际上就是关闭了权限掩码。</p><p><code>umask</code>命令设置的掩码值只能在当前Shell会话中生效，若当前Shell会话结束后，则必须重新设置。</p><h3 id="du" tabindex="-1"><a class="header-anchor" href="#du" aria-hidden="true">#</a> du</h3><p><code>du</code>命令用于查看指定目录的大小。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">du</span> <span class="token parameter variable">-hs</span> /path/to/directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显示第一层子目录的大小。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ du -h -d 1
 45M	./WechatWorkspace
 64K	./docker
2.0G	./VscodeWorkspace
495M	./IdeaWorkspace
1.3G	./Programs
256M	./PycharmWorkspace
597M	./master
6.5G	./GoWorkspace
7.5M	./internalship
 11G	.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数的含义。</p><ul><li><code>-h</code> 表示人类可读的格式</li><li><code>-s</code> 表示总结信息，否则会显示该目录内所有文件和子目录的信息。</li></ul><h3 id="find" tabindex="-1"><a class="header-anchor" href="#find" aria-hidden="true">#</a> find</h3><p>搜索一个给定目录（以及它的子目录），来查找文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>usage: <span class="token function">find</span> <span class="token punctuation">[</span>-H <span class="token operator">|</span> <span class="token parameter variable">-L</span> <span class="token operator">|</span> -P<span class="token punctuation">]</span> <span class="token punctuation">[</span>-EXdsx<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f path<span class="token punctuation">]</span> path <span class="token punctuation">..</span>. <span class="token punctuation">[</span>expression<span class="token punctuation">]</span>
       <span class="token function">find</span> <span class="token punctuation">[</span>-H <span class="token operator">|</span> <span class="token parameter variable">-L</span> <span class="token operator">|</span> -P<span class="token punctuation">]</span> <span class="token punctuation">[</span>-EXdsx<span class="token punctuation">]</span> <span class="token parameter variable">-f</span> path <span class="token punctuation">[</span>path <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>expression<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 输出当前目录的所有子目录和文件（含子目录）</span>
$ <span class="token function">find</span> <span class="token builtin class-name">.</span>
<span class="token comment"># 显示当前目录的文件总数</span>
$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token comment"># 440484</span>
<span class="token comment"># 当前目录的子目录总数</span>
$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-type</span> d <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token comment"># 69113</span>
<span class="token comment"># 当前目录的文件总数（不含子目录）</span>
$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-type</span> f <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span> <span class="token comment"># 371222</span>
<span class="token comment"># 当前目录的文件名匹配“*.JPG”且大于1M的文件总数</span>
$ <span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">&quot;\\*.JPG&quot;</span> <span class="token parameter variable">-size</span> +1M <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-type</code>参数支持的文件类型。</p><ul><li><code>b</code> 块设备文件</li><li><code>c</code> 字符设备文件</li><li><code>d</code> 目录</li><li><code>f</code> 普通文件</li><li><code>l</code> 符号链接</li></ul><p><code>-size</code>参数支持的文件大小类型。</p><ul><li>b 512 个字节块。如果没有指定单位，则这是默认值。</li><li>c 字节</li><li>w 两个字节的字</li><li>k 千字节</li><li>M 兆字节</li><li>G 千兆字节</li></ul><p>这个很强大，超多参数可以参考，还可以正则匹配。</p><h2 id="硬件操作" tabindex="-1"><a class="header-anchor" href="#硬件操作" aria-hidden="true">#</a> 硬件操作</h2><h3 id="df" tabindex="-1"><a class="header-anchor" href="#df" aria-hidden="true">#</a> df</h3><p><code>df</code>命令查看硬盘信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">df</span> <span class="token parameter variable">-h</span>
Filesystem        Size    Used   Avail Capacity iused ifree %iused  Mounted on
/dev/disk3s1s1   228Gi    13Gi    86Gi    <span class="token number">14</span>%    394k  902M    <span class="token number">0</span>%   /
devfs            201Ki   201Ki     0Bi   <span class="token number">100</span>%     <span class="token number">696</span>     <span class="token number">0</span>  <span class="token number">100</span>%   /dev
/dev/disk3s6     228Gi   <span class="token number">1</span>.0Gi    86Gi     <span class="token number">2</span>%       <span class="token number">1</span>  902M    <span class="token number">0</span>%   /System/Volumes/VM
/dev/disk3s2     228Gi    11Gi    86Gi    <span class="token number">12</span>%    <span class="token number">1</span>.1k  902M    <span class="token number">0</span>%   /System/Volumes/Preboot
/dev/disk3s4     228Gi   633Mi    86Gi     <span class="token number">1</span>%     <span class="token number">267</span>  902M    <span class="token number">0</span>%   /System/Volumes/Update
/dev/disk1s2     500Mi   <span class="token number">6</span>.0Mi   482Mi     <span class="token number">2</span>%       <span class="token number">1</span>  <span class="token number">4</span>.9M    <span class="token number">0</span>%   /System/Volumes/xarts
/dev/disk1s1     500Mi   <span class="token number">6</span>.1Mi   482Mi     <span class="token number">2</span>%      <span class="token number">29</span>  <span class="token number">4</span>.9M    <span class="token number">0</span>%   /System/Volumes/iSCPreboot
/dev/disk1s3     500Mi   <span class="token number">1</span>.1Mi   482Mi     <span class="token number">1</span>%     <span class="token number">102</span>  <span class="token number">4</span>.9M    <span class="token number">0</span>%   /System/Volumes/Hardware
/dev/disk3s5     228Gi   115Gi    86Gi    <span class="token number">58</span>%    <span class="token number">2</span>.0M  902M    <span class="token number">0</span>%   /System/Volumes/Data
map auto_home      0Bi     0Bi     0Bi   <span class="token number">100</span>%       <span class="token number">0</span>     <span class="token number">0</span>     -   /System/Volumes/Data/home
/dev/disk3s1     228Gi    13Gi    86Gi    <span class="token number">14</span>%    404k  902M    <span class="token number">0</span>%   /System/Volumes/Update/mnt1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="free" tabindex="-1"><a class="header-anchor" href="#free" aria-hidden="true">#</a> free</h3><p><code>free</code>命令查看内存占用情况。mac的zsh上没这个指令,linux上才有</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@ip-172-31-23-171 ~<span class="token punctuation">]</span><span class="token comment"># free</span>
               total        used        <span class="token function">free</span>      shared  buff/cache   available
Mem:        <span class="token number">15985008</span>     <span class="token number">9510064</span>      <span class="token number">149716</span>        <span class="token number">8852</span>     <span class="token number">6325228</span>     <span class="token number">6129812</span>
Swap:              <span class="token number">0</span>           <span class="token number">0</span>           <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mount" tabindex="-1"><a class="header-anchor" href="#mount" aria-hidden="true">#</a> mount</h3><p><code>mount</code>不带参数时，显示当前挂载的文件系统。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">mount</span>
/dev/disk3s1s1 on / <span class="token punctuation">(</span>apfs, sealed, local, read-only, journaled<span class="token punctuation">)</span>
devfs on /dev <span class="token punctuation">(</span>devfs, local, nobrowse<span class="token punctuation">)</span>
/dev/disk3s6 on /System/Volumes/VM <span class="token punctuation">(</span>apfs, local, noexec, journaled, noatime, nobrowse<span class="token punctuation">)</span>
/dev/disk3s2 on /System/Volumes/Preboot <span class="token punctuation">(</span>apfs, local, journaled, nobrowse<span class="token punctuation">)</span>
/dev/disk3s4 on /System/Volumes/Update <span class="token punctuation">(</span>apfs, local, journaled, nobrowse<span class="token punctuation">)</span>
/dev/disk1s2 on /System/Volumes/xarts <span class="token punctuation">(</span>apfs, local, noexec, journaled, noatime, nobrowse<span class="token punctuation">)</span>
/dev/disk1s1 on /System/Volumes/iSCPreboot <span class="token punctuation">(</span>apfs, local, journaled, nobrowse<span class="token punctuation">)</span>
/dev/disk1s3 on /System/Volumes/Hardware <span class="token punctuation">(</span>apfs, local, journaled, nobrowse<span class="token punctuation">)</span>
/dev/disk3s5 on /System/Volumes/Data <span class="token punctuation">(</span>apfs, local, journaled, nobrowse, protect<span class="token punctuation">)</span>
map auto_home on /System/Volumes/Data/home <span class="token punctuation">(</span>autofs, automounted, nobrowse<span class="token punctuation">)</span>
/dev/disk3s1 on /System/Volumes/Update/mnt1 <span class="token punctuation">(</span>apfs, sealed, local, journaled, nobrowse<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>mount</code>带参数时，用于将设备文件挂载到挂载点，<code>-t</code>参数用来指定文件系统类型。</p><p><strong>umount</strong></p><p><code>umount</code>命令用来卸载设备。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">umount</span> <span class="token punctuation">[</span>设备名<span class="token punctuation">]</span>
$ <span class="token function">umount</span> /dev/hdc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="命名管道" tabindex="-1"><a class="header-anchor" href="#命名管道" aria-hidden="true">#</a> 命名管道</h2><p>在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。</p><p>命令管道的行为类似于文件，但实际上形成了<strong>先入先出（FIFO）的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现</strong>。通过命令管道，有可能像这样设置一些东西：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>process1 &gt; named_pipe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>和</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>process2 &lt; named_pipe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表现出来就像这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>process1 | process2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置一个命名管道</p><p>使用 mkfifo 命令能够创建命令管道：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">mkfifo</span> pipe1
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> pipe1  
prw-r--r--  <span class="token number">1</span> liushun  staff  <span class="token number">0</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">12</span>:50 pipe1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。</p><p>使用命名管道</p><p>为了演示命名管道是如何工作的，将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，输入一个简单命令，并把命令的输出重定向到命名管道：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ ls -l &gt; pipe1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。 使用第二个终端窗口，输入这个命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;</span> pipe1 
total <span class="token number">8</span>
drwx------@   <span class="token number">4</span> liushun  staff   <span class="token number">128</span>  <span class="token number">9</span> <span class="token number">23</span> <span class="token number">21</span>:37 Applications
drwx------@   <span class="token number">7</span> liushun  staff   <span class="token number">224</span> <span class="token number">10</span> <span class="token number">17</span> <span class="token number">10</span>:42 Desktop
drwx------+  <span class="token number">16</span> liushun  staff   <span class="token number">512</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">10</span>:14 Documents
drwx------@  <span class="token number">16</span> liushun  staff   <span class="token number">512</span> <span class="token number">10</span> <span class="token number">17</span> <span class="token number">13</span>:31 Downloads
drwx------@ <span class="token number">104</span> liushun  staff  <span class="token number">3328</span>  <span class="token number">9</span> <span class="token number">24</span> <span class="token number">20</span>:19 Library
drwx------    <span class="token number">5</span> liushun  staff   <span class="token number">160</span>  <span class="token number">4</span> <span class="token number">10</span>  <span class="token number">2024</span> Movies
drwx------+   <span class="token number">6</span> liushun  staff   <span class="token number">192</span>  <span class="token number">3</span> <span class="token number">10</span>  <span class="token number">2024</span> Music
drwx------+   <span class="token number">5</span> liushun  staff   <span class="token number">160</span>  <span class="token number">3</span> <span class="token number">10</span>  <span class="token number">2024</span> Pictures
drwxr-xr-x@   <span class="token number">3</span> liushun  staff    <span class="token number">96</span>  <span class="token number">4</span> <span class="token number">15</span>  <span class="token number">2024</span> Postman
drwxr-xr-x+   <span class="token number">5</span> liushun  staff   <span class="token number">160</span>  <span class="token number">3</span> <span class="token number">10</span>  <span class="token number">2024</span> Public
drwxr-xr-x    <span class="token number">4</span> liushun  staff   <span class="token number">128</span>  <span class="token number">9</span> <span class="token number">24</span> <span class="token number">20</span>:20 ScreenPal
drwx------    <span class="token number">3</span> liushun  staff    <span class="token number">96</span>  <span class="token number">8</span> <span class="token number">10</span> <span class="token number">17</span>:28 default.etcd
-rw-r--r--    <span class="token number">1</span> liushun  staff   <span class="token number">100</span>  <span class="token number">9</span>  <span class="token number">1</span> <span class="token number">16</span>:15 dump.rdb
drwxr-xr-x    <span class="token number">3</span> liushun  staff    <span class="token number">96</span>  <span class="token number">9</span>  <span class="token number">6</span> <span class="token number">17</span>:36 go
drwxr-xr-x    <span class="token number">4</span> liushun  staff   <span class="token number">128</span>  <span class="token number">7</span> <span class="token number">16</span> <span class="token number">17</span>:10 logs
drwxr-xr-x    <span class="token number">4</span> liushun  staff   <span class="token number">128</span>  <span class="token number">7</span> <span class="token number">16</span> <span class="token number">17</span>:10 nacos
prw-r--r--    <span class="token number">1</span> liushun  staff     <span class="token number">0</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">12</span>:48 pipe1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。</p><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h2><h3 id="ps" tabindex="-1"><a class="header-anchor" href="#ps" aria-hidden="true">#</a> ps</h3><p><code>ps</code>命令用来列出进程信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ps</span>
	PID TTY           TIME CMD
<span class="token number">72215</span> ttys000    <span class="token number">0</span>:01.76 <span class="token parameter variable">-zsh</span>
<span class="token number">45118</span> ttys001    <span class="token number">0</span>:07.12 <span class="token parameter variable">-zsh</span>
<span class="token number">12351</span> ttys002    <span class="token number">0</span>:03.31 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
<span class="token number">12411</span> ttys003    <span class="token number">0</span>:10.01 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
<span class="token number">46581</span> ttys005    <span class="token number">0</span>:00.60 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不带任何参数时，<code>ps</code>只列出与当前Session相关的进程。输出结果中，<code>PID</code>是进程ID、<code>TTY</code>是进程的终端号（如果显示<code>?</code>，则表示进程没有终端），<code>TIME</code>是消耗的CPU时间，<code>CMD</code>是触发进程的命令。</p><p><code>x</code>参数列出所有进程的详细信息，包括不在当前Session的信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> x   
  PID   TT  STAT      TIME COMMAND
  <span class="token number">575</span>   ??  S      <span class="token number">9</span>:56.72 /usr/sbin/distnoted agent
  <span class="token number">576</span>   ??  S      <span class="token number">4</span>:40.03 /usr/sbin/cfprefsd agent
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果，会多出<code>STAT</code>一栏，表示状态。它的各种值如下。</p><ul><li><code>R</code> 正在运行或准备运行</li><li><code>S</code> 正在睡眠，即没有运行，正在等待一个事件唤醒</li><li><code>D</code> 不可中断睡眠。进程正在等待 I/O，比如磁盘驱动器的I/O</li><li><code>T</code> 已停止，即进程停止运行</li><li><code>Z</code> “僵尸”进程。即这是一个已经终止的子进程，但父进程还没有清空它（没有把子进程从进程表中删除）</li><li><code>&lt;</code> 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。</li><li><code>N</code> 低优先级进程。一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。</li></ul><p><code>aux</code>参数可以显示更多信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ps</span> aux 
<span class="token environment constant">USER</span>               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
_windowserver      <span class="token number">368</span>  <span class="token number">23.2</span>  <span class="token number">0.7</span> <span class="token number">415379072</span> <span class="token number">120864</span>   ??  Ss    <span class="token number">71024</span>  <span class="token number">1841</span>:00.04 /System/Library/PrivateFrameworks/SkyLig
liushun          <span class="token number">34285</span>   <span class="token number">9.2</span>  <span class="token number">0.2</span> <span class="token number">410272800</span>  <span class="token number">40416</span>   ??  S    三09上午 <span class="token number">207</span>:24.90 /Applications/Xmind.app/Contents/Framewo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果包含的列的含义如下。</p><ul><li><code>USER</code> 用户ID，表示进程的所有者</li><li><code>%CPU</code> 百分比表示的 CPU 使用率</li><li><code>%MEM</code> 百分比表示的内存使用率</li><li><code>VSZ</code> 虚拟内存大小</li><li><code>RSS</code> 进程占用的物理内存的大小，以千字节为单位。</li><li><code>START</code> 进程运行的起始时间。若超过24小时，则用天表示。</li></ul><h3 id="top" tabindex="-1"><a class="header-anchor" href="#top" aria-hidden="true">#</a> top</h3><p><code>top</code>命令可以查看机器的当前状态。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">top</span>
<span class="token function">top</span> - 05:11:56 up <span class="token number">79</span> days, <span class="token number">20</span>:18,  <span class="token number">2</span> users,  load average: <span class="token number">0.11</span>, <span class="token number">0.07</span>, <span class="token number">0.09</span>
Tasks: <span class="token number">198</span> total,   <span class="token number">1</span> running, <span class="token number">197</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie
%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.7</span> us,  <span class="token number">0.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">98.6</span> id,  <span class="token number">0.5</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.2</span> si,  <span class="token number">0.0</span> st
MiB Mem <span class="token builtin class-name">:</span>  <span class="token number">15610.4</span> total,    <span class="token number">154.7</span> free,   <span class="token number">9308.2</span> used,   <span class="token number">6147.5</span> buff/cache
MiB Swap:      <span class="token number">0.0</span> total,      <span class="token number">0.0</span> free,      <span class="token number">0.0</span> used.   <span class="token number">5965.4</span> avail Mem 

    PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                           
<span class="token number">3320879</span> root      <span class="token number">20</span>   <span class="token number">0</span>   <span class="token number">12</span>.7g   <span class="token number">8</span>.8g  <span class="token number">20232</span> S  <span class="token number">11.3</span>  <span class="token number">57.4</span> <span class="token number">376</span>:02.79 geth-linux                         
<span class="token number">3387071</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">224036</span>   <span class="token number">3648</span>   <span class="token number">2860</span> R   <span class="token number">0.3</span>   <span class="token number">0.0</span>   <span class="token number">0</span>:00.02 <span class="token function">top</span>         
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的输出结果分为两部分，最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。</p><h3 id="jobs" tabindex="-1"><a class="header-anchor" href="#jobs" aria-hidden="true">#</a> jobs</h3><p><code>jobs</code>命令用来查看后台任务。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ jobs
[1]+ Running            xlogo &amp;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果之中，每个后台任务会有一个编号。上面结果中，<code>xlogo</code>的编号是<code>1</code>，<code>+</code>表示正在运行。</p><h3 id="fg" tabindex="-1"><a class="header-anchor" href="#fg" aria-hidden="true">#</a> fg</h3><p><code>fg</code>命令用于将后台任务切换到前台。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ fg %1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>fg</code>命令之后，跟随着一个百分号和工作序号，用来指定切换哪一个后台任务。如果只有一个后台任务，那么<code>fg</code>命令可以不带参数。</p><h3 id="bg" tabindex="-1"><a class="header-anchor" href="#bg" aria-hidden="true">#</a> bg</h3><p><code>bg</code>命令用于将一个暂停的前台任务，转移到后台。只有暂停的任务，才能使用<code>bg</code>命令，因为正在运行的任务，命令行是无法输入的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ bg %1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Ctrl + z</code>可以暂停正在运行的前台任务。</p><h3 id="kill" tabindex="-1"><a class="header-anchor" href="#kill" aria-hidden="true">#</a> kill</h3><p><code>kill</code>命令用于杀死进程。它的参数是进程ID。</p><p><code>kill</code>命令的实质是操作系统向进程发送信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（终端停止）的信号。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ kill [-signal] PID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是常见信号。</p><ul><li>HUP：编号1，表示挂起。发送这个信号到前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</li><li><strong>INT：编号2，中断。实现和<code>Ctrl-c</code>一样的功能，由终端发送。通常，它会终止一个程序。</strong></li><li><strong>KILL：编号9，杀死。<strong>进程可能选择忽略这个信号。所以，操作系统不发送该信号到目标进程，而是</strong>内核立即终止这个进程</strong>。当一个进程以这种方式终止的时候，<strong>它没有机会去做些“清理”工作</strong>，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。</li><li>TERM：编号15，终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。</li><li>CONT：编号18，继续。在停止一段时间后，进程恢复运行。</li><li>STOP：编号19，停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。</li><li>QUIT：编号3，退出</li><li>SEGV：编号11，段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说，程序试图写入内存，而这个内存空间是不允许此程序写入的。</li><li>TSTP：编号20，终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。</li><li>WINCH：编号28，改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。</li></ul><p><code>-l</code>参数可以列出所有信号。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">kill</span> <span class="token parameter variable">-l</span>
HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM <span class="token environment constant">TERM</span> URG STOP TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>pstree</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@ip-172-31-23-171 ~<span class="token punctuation">]</span><span class="token comment"># pstree</span>
systemd─┬─2*<span class="token punctuation">[</span>agetty<span class="token punctuation">]</span>
        ├─amazon-ssm-agen───10*<span class="token punctuation">[</span><span class="token punctuation">{</span>amazon-ssm-agen<span class="token punctuation">}</span><span class="token punctuation">]</span>
        ├─atd
        ├─auditd───<span class="token punctuation">{</span>auditd<span class="token punctuation">}</span>
        ├─chronyd
        ├─dbus-broker-lau───dbus-broker
        ├─geth-linux───29*<span class="token punctuation">[</span><span class="token punctuation">{</span>geth-linux<span class="token punctuation">}</span><span class="token punctuation">]</span>
        ├─gssproxy───5*<span class="token punctuation">[</span><span class="token punctuation">{</span>gssproxy<span class="token punctuation">}</span><span class="token punctuation">]</span>
        ├─irqbalance───<span class="token punctuation">{</span>irqbalance<span class="token punctuation">}</span>
        ├─lsmd
        ├─nginx───8*<span class="token punctuation">[</span>nginx<span class="token punctuation">]</span>
        ├─rngd───4*<span class="token punctuation">[</span><span class="token punctuation">{</span>rngd<span class="token punctuation">}</span><span class="token punctuation">]</span>
        ├─sshd─┬─sshd───sshd───bash
        │      └─sshd───sshd───bash───pstree
        ├─systemd───<span class="token punctuation">(</span>sd-pam<span class="token punctuation">)</span>
        ├─systemd-homed
        ├─systemd-inhibit───acpid
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-network
        ├─systemd-resolve
        ├─systemd-udevd
        └─systemd-userdbd───3*<span class="token punctuation">[</span>systemd-userwor<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h2><h3 id="输入输出" tabindex="-1"><a class="header-anchor" href="#输入输出" aria-hidden="true">#</a> 输入输出</h3><table><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">command &gt; file</td><td style="text-align:left;">将输出重定向到 file。</td></tr><tr><td style="text-align:left;">command &lt; file</td><td style="text-align:left;">将输入重定向到 file。</td></tr><tr><td style="text-align:left;">command &gt;&gt; file</td><td style="text-align:left;">将输出以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left;">n &gt; file</td><td style="text-align:left;">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td style="text-align:left;">n &gt;&gt; file</td><td style="text-align:left;">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left;">n &gt;&amp; m</td><td style="text-align:left;">将输出文件 m 和 n 合并。</td></tr><tr><td style="text-align:left;">n &lt;&amp; m</td><td style="text-align:left;">将输入文件 m 和 n 合并。</td></tr><tr><td style="text-align:left;">&lt;&lt; tag</td><td style="text-align:left;">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p><strong>&gt;</strong></p><p><code>&gt;</code>用来将标准输出重定向到指定文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;</span> ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果重定向后的指定文件已经存在，就会被覆盖，不会有任何提示。</p><p>如果命令没有任何输出，那么重定向之后，得到的是一个长度为<code>0</code>的文件。因此，<code>&gt;</code>具有创建新文件或改写现存文件、将其改为长度<code>0</code>的作用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> 复制代码$ <span class="token operator">&gt;</span> ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>&gt;&gt;</strong></p><p><code>&gt;&gt;</code>用来将标准输出重定向追加到指定文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/bin <span class="token operator">&gt;&gt;</span> ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2&gt;</strong></p><p><code>2&gt;</code>用来将标准错误重定向到指定文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> ls-error.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>标准输出和标准错误，可以重定向到同一个文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&gt;</span> ls-output.txt <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token comment"># 将2合并到1，然后输出到1</span>
<span class="token comment"># 或者</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&amp;&gt;</span> ls-output.txt
<span class="token comment"># 追加到同一个文件</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator">&amp;&gt;&gt;</span> ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不希望输出错误信息，可以将它重定向到一个特殊文件<code>/dev/null</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> /bin/usr <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>|</strong></p><p><code>|</code>用于将一个命令的标准输出，重定向到另一个命令的标准输入。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ ls -l /usr/bin | less
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不要将<code>&gt;</code>与<code>|</code>混淆。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ ls &gt; less
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会在当前目录，生成一个名为<code>less</code>的文本文件。</p><p><strong>tee</strong></p><p><code>tee</code>命令用于同时将标准输出重定向到文件，以及另一个命令的标准输入。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">tee</span> ls.txt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="命令替换" tabindex="-1"><a class="header-anchor" href="#命令替换" aria-hidden="true">#</a> 命令替换</h3><p>命令替换（command substitution）指的是将一个命令的输出，替换进入另一个命令。<code>$(command)</code>表示命令替换，另一种写法是使用反引号。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span><span class="token variable">)</span></span><span class="token comment"># 或者</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">ls</span><span class="token variable">\`</span></span>
<span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">ls</span><span class="token variable">\`</span></span>          
Applications Desktop Documents Downloads Library Movies Music Pictures Postman Public ScreenPal default.etcd dump.rdb go logs nacos pipe1
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">which</span> <span class="token function">cp</span><span class="token variable">)</span></span><span class="token comment"># 或者</span>
$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">which</span> <span class="token function">cp</span><span class="token variable">\`</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="basename" tabindex="-1"><a class="header-anchor" href="#basename" aria-hidden="true">#</a> basename</h3><p><code>basename</code>命令清除 一个路径名的开头部分，只留下一个文件的基本名称。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">basename</span> docker/compose/Docker
Docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="系统信息" tabindex="-1"><a class="header-anchor" href="#系统信息" aria-hidden="true">#</a> 系统信息</h2><h3 id="uname" tabindex="-1"><a class="header-anchor" href="#uname" aria-hidden="true">#</a> uname</h3><p><code>uname</code>命令返回当前机器的信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 内核的版本</span>
$ <span class="token function">uname</span> <span class="token parameter variable">-r</span>
<span class="token number">23.2</span>.0
<span class="token comment"># CPU 架构</span>
$ <span class="token function">uname</span> <span class="token parameter variable">-m</span> 
arm64
$ <span class="token function">uname</span> <span class="token parameter variable">-a</span> 
Darwin ls.local <span class="token number">23.2</span>.0 Darwin Kernel Version <span class="token number">23.2</span>.0: Wed Nov <span class="token number">15</span> <span class="token number">21</span>:59:33 PST <span class="token number">2023</span><span class="token punctuation">;</span> root:xnu-10002.61.3~2/RELEASE_ARM64_T8112 arm64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="service" tabindex="-1"><a class="header-anchor" href="#service" aria-hidden="true">#</a> service</h3><p><code>service</code>命令可以查看当前正在运行的服务。mac上没有</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">service</span> --status-all
 <span class="token punctuation">[</span> + <span class="token punctuation">]</span>  apache2
 <span class="token punctuation">[</span> ? <span class="token punctuation">]</span>  atd
 <span class="token punctuation">[</span> - <span class="token punctuation">]</span>  bootlogd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>+</code>表示正在运行，<code>-</code>表示已经停止，<code>?</code>表示<code>service</code>命令不了解相关信息。</p><h2 id="文本处理" tabindex="-1"><a class="header-anchor" href="#文本处理" aria-hidden="true">#</a> 文本处理</h2><p><strong>cat</strong></p><p><code>cat</code>可以文件的内容，显示在标准输出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> test.txt 
hello world<span class="token operator">!</span>
abd
dahk
wqowie
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它也可以同时输出多个文件内容。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ cat text1 text2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果调用<code>cat</code>命令时没有任何参数，它将读取标准输入，然后显示到标准输出。按下<code>Ctrl + d</code>，将会结束<code>cat</code>读取标准输入。利用这一点，可以将键盘输入写入指定文件，按下<code>Ctrl + d</code>结束输入。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ cat &gt; lazy_dog.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的参数如下。</p><ul><li><code>-n</code> 输出结果显示行号</li><li><code>-s</code> 将多个连续的空白行，输出为一行</li><li><code>-A</code> 输出结果中显示控制符，比如Tab键显示为<code>^I</code>，行尾显示<code>$</code></li></ul><p><strong>nl</strong></p><p><code>nl</code>命令为文本文件添加行号，显示在标准输出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">nl</span> test.txt 
     <span class="token number">1</span>	hello world<span class="token operator">!</span>
     <span class="token number">2</span>	abd
     <span class="token number">3</span>	dahk
     <span class="token number">4</span>	wqowie
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>sort</strong></p><p><code>sort</code>命令将文本文件的所有行排序后输出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sort</span> test.txt  
abd
dahk
hello world<span class="token operator">!</span>
wqowie
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>-b</code> <code>--ignore-leading-blanks</code> 默认情况下，排序用的是每行的第一个字符。这个参数忽略每行开头的空格，从第一个非空白字符开始排序。</li><li><code>-f</code> <code>--ignore-case</code> 让排序不区分大小写。</li><li><code>-n</code> <code>--numeric-sort</code> 按照数值排序，而不是字符值，用于行首是数值的情况。</li><li><code>-r</code> <code>--reverse</code> 按相反顺序排序。结果按照降序排列，而不是升序。</li><li><code>-o</code> <code>--output=file</code> 把排好序的输出结果发送到文件，而不是标准输出。</li><li><code>-u</code> 输出结果中删除重复行</li></ul><p><strong>wc</strong></p><p><code>wc</code>命令输出一个文本文件的统计信息（word count），一共有三个值，分别为行数、词数和字节数。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ wc test.txt 
       4       5      29 test.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用<code>-l</code>参数，则只输出行数。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>wc -l test.txt 
       4 test.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>head</strong></p><p><code>head</code>命令返回文本文件的头部，默认显示10行。</p><p><code>-n</code>参数指定显示的行数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">5</span> ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>tail</strong></p><p><code>tail</code>命令返回文本文件的尾部，默认显示10行。</p><p><code>-n</code>参数指定显示的行数。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ tail -n 5 ls-output.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>-f</code>会实时追加显示新增的内容，常用于实时监控日志，按<code>Ctrl + c</code>停止。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ tail -100f /var/log/messages
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>grep</strong></p><p><code>grep</code>程序用于在指定文件之中，搜索符合某个模式的行，并把搜索结果输出到标准输出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">grep</span> keyword foo.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>grep</code>程序可以同时搜索多个文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">grep</span> keyword f*.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>-l</code>参数输出匹配的文件名，而不是文件行。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">grep</span> <span class="token parameter variable">-l</span> bzip dirlist*.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果想搜索文件名，而不是文件内容，可以使用重定向。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> /usr/bin <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">zip</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会输出<code>/usr/bin</code>目录中，文件名中包含子字符串<code>zip</code>的所有文件。</p><p>参数的含义。</p><ul><li><code>-c</code>或<code>--count</code> 输出匹配的数量，而不是匹配的文本行。如果使用了<code>-v</code>，则输出不匹配的数量。</li><li><code>-h</code>或<code>--no-filename</code> 应用于多文件搜索，不在每行匹配的文本前，输出文件名</li><li><code>-i</code>或<code>--ignore-case</code> 忽略大小写</li><li><code>-l</code>或<code>--files-with-matches</code> 输出包含匹配项的文件名，而不是文本行本身</li><li><code>-L</code>或<code>--files-without-match</code> 类似于<code>-l</code>，但输出不包含匹配项的文件名</li><li><code>-n</code>或<code>--line-number</code> 每个匹配行之前输出其对应的行号</li><li><code>-v</code>或<code>--invert-match</code> 只返回不符合模式的行</li></ul><h2 id="时间管理" tabindex="-1"><a class="header-anchor" href="#时间管理" aria-hidden="true">#</a> 时间管理</h2><h2 id="date-命令" tabindex="-1"><a class="header-anchor" href="#date-命令" aria-hidden="true">#</a> date 命令</h2><p><code>date</code>命令用于输出当前时间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ date       
2024年10月20日 星期日 16时30分52秒 CST
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>date</code>命令后面用加号（<code>+</code>）指定显示的格式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">date</span> +%d_%b_%Y
20_10_2024
$ <span class="token function">date</span> +%D      
<span class="token number">10</span>/20/24
$ <span class="token function">date</span> +%F-%T
<span class="token number">2024</span>-10-20-16:31:31
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的格式参数如下。</p><ul><li>%a 星期名的缩写（Sun）</li><li>%A 星期名的全称（Sunday）</li><li>%b 月份的缩写（Jan）</li><li>%B 月份的全称（January）</li><li>%c 日期和时间（Thu Mar 3 23:05:25 2005）</li><li>%C 世纪，就是年份数省略后两位（20）</li><li>%d 一个月的第几天（01）</li><li>%D 日期，等同于<code>%m/%d/%y</code></li><li>%e 一个月的第几天，用空格补零，等同于<code>%_d</code></li><li>%F 完整的日期，等同于<code>%Y-%m-%d</code></li><li>%g last two digits of year of ISO week number (see %G)</li><li>%G year of ISO week number (see %V); normally useful only with %V</li><li>%h 等同于<code>%b</code></li><li>%H 小时（00..23）</li><li>%I 小时（01..12）</li><li>%j day of year (001..366)</li><li>%k hour ( 0..23)</li><li>%l hour ( 1..12)</li><li>%m month (01..12)</li><li>%M minute (00..59)</li><li>%N nanoseconds (000000000..999999999)</li><li>%p locale’s equivalent of either AM or PM; blank if not known</li><li>%P like %p, but lower case</li><li>%r locale’s 12-hour clock time (e.g., 11:11:04 PM)</li><li>%R 24-hour hour and minute; same as %H:%M</li><li>%s seconds since 1970-01-01 00:00:00 UTC</li><li>%S second (00..60)</li><li>%T time; same as %H:%M:%S</li><li>%u day of week (1..7); 1 is Monday</li><li>%U week number of year, with Sunday as first day of week (00..53)</li><li>%V ISO week number, with Monday as first day of week (01..53)</li><li>%w day of week (0..6); 0 is Sunday</li><li>%W week number of year, with Monday as first day of week (00..53)</li><li>%x locale’s date representation (e.g., 12/31/99)</li><li>%X locale’s time representation (e.g., 23:13:48)</li><li>%y last two digits of year (00..99)</li><li>%Y year</li><li>%z +hhmm numeric timezone (e.g., -0400)</li><li>%😒 +hh:mm numeric timezone (e.g., -04:00)</li><li>%:😒 +hh:mm:ss numeric time zone (e.g., -04:00:00)</li><li>%Z alphabetic time zone abbreviation (e.g., EDT)</li></ul><h2 id="cal-命令" tabindex="-1"><a class="header-anchor" href="#cal-命令" aria-hidden="true">#</a> cal 命令</h2><p><code>cal</code>命令用于显示日历。不带有参数时，显示的是当前月份。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cal</span>         
      十月 <span class="token number">2024</span>         
日 一 二 三 四 五 六  
       <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  
 <span class="token number">6</span>  <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span>  
<span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span>  
<span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span>  
<span class="token number">27</span> <span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span> 
$ <span class="token function">cal</span> <span class="token number">9</span> <span class="token number">2024</span>
      九月 <span class="token number">2024</span>         
日 一 二 三 四 五 六  
 <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  <span class="token number">6</span>  <span class="token number">7</span>  
 <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span>  
<span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span> <span class="token number">21</span>  
<span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span> <span class="token number">28</span>  
<span class="token number">29</span> <span class="token number">30</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="用户管理" tabindex="-1"><a class="header-anchor" href="#用户管理" aria-hidden="true">#</a> 用户管理</h2><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><strong>id</strong></p><p><code>id</code>命令用于查看指定用户的用户名和组名。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">id</span>
<span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">501</span><span class="token punctuation">(</span>liushun<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">(</span>staff<span class="token punctuation">)</span>,12<span class="token punctuation">(</span>everyone<span class="token punctuation">)</span>,61<span class="token punctuation">(</span>localaccounts<span class="token punctuation">)</span>,79<span class="token punctuation">(</span>_appserverusr<span class="token punctuation">)</span>,80<span class="token punctuation">(</span>admin<span class="token punctuation">)</span>,81<span class="token punctuation">(</span>_appserveradm<span class="token punctuation">)</span>,98<span class="token punctuation">(</span>_lpadmin<span class="token punctuation">)</span>,701<span class="token punctuation">(</span>com.apple.sharepoint.group.1<span class="token punctuation">)</span>,33<span class="token punctuation">(</span>_appstore<span class="token punctuation">)</span>,100<span class="token punctuation">(</span>_lpoperator<span class="token punctuation">)</span>,204<span class="token punctuation">(</span>_developer<span class="token punctuation">)</span>,250<span class="token punctuation">(</span>_analyticsusers<span class="token punctuation">)</span>,395<span class="token punctuation">(</span>com.apple.access_ftp<span class="token punctuation">)</span>,398<span class="token punctuation">(</span>com.apple.access_screensharing<span class="token punctuation">)</span>,399<span class="token punctuation">(</span>com.apple.access_ssh<span class="token punctuation">)</span>,400<span class="token punctuation">(</span>com.apple.access_remote_ae<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>id</code>输出结果分为三个部分，分别是UID（用户编号和用户名）、GID（组编号和组名），groups（用户所在的所有组）。</p><p>用户帐户的信息，存放在<code>/etc/passwd</code>文件里面；用户组的信息，存放在<code>/etc/group</code>文件里面。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回UID</span>
$ <span class="token function">id</span> <span class="token parameter variable">-u</span> <span class="token punctuation">[</span>UserName<span class="token punctuation">]</span>
<span class="token number">501</span>
<span class="token comment"># 返回GID</span>
$ <span class="token function">id</span> <span class="token parameter variable">-g</span> <span class="token punctuation">[</span>UserName<span class="token punctuation">]</span>
<span class="token number">20</span>
<span class="token comment"># 返回用户名</span>
$ <span class="token function">id</span> <span class="token parameter variable">-un</span> <span class="token punctuation">[</span>UserName<span class="token punctuation">]</span>
liushun
<span class="token comment"># 返回组名</span>
$ <span class="token function">id</span> <span class="token parameter variable">-gn</span> <span class="token punctuation">[</span>UserName<span class="token punctuation">]</span>
staff
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的命令，如果省略用户名，则返回当前用户的信息。</p><p><strong>su</strong></p><p><code>su</code>命令允许以另一个用户的身份，启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">su</span> otherUser
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行上面的命令以后，系统会提示输入密码。通过以后，就以另一个用户身份在执行命令了。</p><p>如果不加用户名，则表示切换到root用户。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">su</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>-l</code>参数表示启动一个需要登录的新的Shell，这意味着工作目录会切换到该用户的主目录。它的缩写形式是<code>-</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">su</span> -
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令表示，切换到root用户的身份，且工作目录也切换到root用户的主目录。</p><p><code>-c</code>参数表示只以其他用户的身份，执行单个命令，而不是启动一个新的Session。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">&#39;command&#39;</span> <span class="token comment"># 实例</span>
$ <span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">&#39;ls -l /root/*&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>sudo</strong></p><p><code>sudo</code>命令很类似<code>su</code>命令，但有几点差别。</p><ul><li>对于管理员来说，<code>sudo</code>命令的可配置性更高</li><li><code>sudo</code>命令通常只用于执行单个命令，而不是开启另一个Session。</li><li><code>sudo</code>命令不要求超级用户的密码，而是用户使自己的密码来认证。</li></ul><p><code>sudo</code>的设置在文件<code>/etc/sudoers</code>之中。</p><p><code>-l</code>参数列出用户拥有的所有权限。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token parameter variable">-l</span>                      
Password:
Matching Defaults entries <span class="token keyword">for</span> liushun on ls:
    env_reset, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span>BLOCKSIZE, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;COLORFGBG COLORTERM&quot;</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span>__CF_USER_TEXT_ENCODING,
    <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;CHARSET LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE&quot;</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;LC_MESSAGES LC_MONETARY LC_NUMERIC LC_TIME&quot;</span>,
    <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;LINES COLUMNS&quot;</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span>LSCOLORS, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token environment constant">SSH_AUTH_SOCK</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span>TZ, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;DISPLAY
    XAUTHORIZATION XAUTHORITY&quot;</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;EDITOR VISUAL&quot;</span>, <span class="token assign-left variable">env_keep</span><span class="token operator">+=</span><span class="token string">&quot;HOME MAIL&quot;</span>, <span class="token assign-left variable">lecture_file</span><span class="token operator">=</span>/etc/sudo_lecture

User liushun may run the following commands on ls:
    <span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> ALL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>chown</strong></p><p><code>chown</code>命令用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ chown [owner][:[group]] file
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是一些例子。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 更改文件所有者</span>
$ <span class="token function">sudo</span> <span class="token function">chown</span> bob foo.txt
<span class="token comment"># 更改文件所有者和用户组</span>
$ <span class="token function">sudo</span> <span class="token function">chown</span> bob:users foo.txt
<span class="token comment"># 更改用户组</span>
$ <span class="token function">sudo</span> <span class="token function">chown</span> :admins foo.txt
<span class="token comment"># 更改文件所有者和用户组（用户 bob 登录系统时，所属的用户组）</span>
$ <span class="token function">sudo</span> <span class="token function">chown</span> bob: foo.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>chgrp</strong></p><p><code>chgrp</code>命令更改用户组，用法与<code>chown</code>命令类似。</p><p><strong>useradd</strong></p><p><code>useradd</code>命令用来新增用户。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">useradd</span> <span class="token parameter variable">-G</span> admin <span class="token parameter variable">-d</span> /home/bill <span class="token parameter variable">-s</span> /bin/bash <span class="token parameter variable">-m</span> bill
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令新增用户<code>bill</code>，参数<code>-G</code>指定用户所在的组，参数<code>d</code>指定用户的主目录，参数<code>s</code>指定用户的 Shell，参数<code>m</code>表示如果该目录不存在，则创建该目录。</p><p><strong>usermod</strong></p><p><code>usermod</code>命令用来修改用户的各项属性。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">usermod</span> <span class="token parameter variable">-g</span> sales jerry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令修改用户<code>jerry</code>属于的主要用户组为<code>sales</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">usermod</span> <span class="token parameter variable">-G</span> sales jerry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令修改用户<code>jerry</code>属于的次要用户组为<code>sales</code>。</p><p><strong>adduser</strong></p><p><code>adduser</code>命令用来将一个用户加入用户组。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> adduser username grouptoadd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>groupadd</strong></p><p><code>groupadd</code>命令用来新建一个用户组。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">groupadd</span> group1
$ <span class="token function">sudo</span> adduser foobar group1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>groupdel</strong></p><p><code>groupdel</code>命令用来删除一个用户组。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">groupdel</span> group1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>passwd</strong></p><p><code>passwd</code>命令用于修改密码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 修改自己的密码</span>
$ <span class="token function">passwd</span>
<span class="token comment"># 修改其他用户的密码</span>
$ <span class="token function">sudo</span> <span class="token function">passwd</span> <span class="token punctuation">[</span>user<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="shell命令" tabindex="-1"><a class="header-anchor" href="#shell命令" aria-hidden="true">#</a> shell命令</h2><p><strong>命令的类别</strong></p><p>Bash可以使用的命令分成四类。</p><ul><li>可执行程序</li><li>Shell 提供的命令</li><li>Shell 函数</li><li>前三类命令的别名</li></ul><p><strong>type, whatis</strong></p><p><code>type</code>命令可以显示命令类型。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">type</span> <span class="token builtin class-name">command</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是几个例子。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">type</span> <span class="token function">ls</span>   
<span class="token function">ls</span> is an <span class="token builtin class-name">alias</span> <span class="token keyword">for</span> <span class="token function">ls</span> <span class="token parameter variable">-G</span>
$ <span class="token builtin class-name">type</span> <span class="token function">cp</span>
<span class="token function">cp</span> is /bin/cp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>whatis</code>命令显示指定命令的描述。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ whatis <span class="token function">ls</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>alias, unalias</strong></p><p><code>alias</code>命令用来为命令起别名。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">alias</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">&#39;cd /usr; ls; cd -&#39;</span>
$ <span class="token builtin class-name">type</span> foo
foo is aliased to \`cd /usr<span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token punctuation">;</span> <span class="token builtin class-name">cd</span> -&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，默认情况下，别名只在当前Session有效。当前Session结束时，这些别名就会消失。</p><p><code>alias</code>命令不加参数时，显示所有有效的别名。</p><p><code>unalias</code>命令用来取消别名。</p><p><strong>which</strong></p><p><code>which</code>命令显示可执行程序的路径。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">which</span> <span class="token function">ls</span>
/bin/ls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>which</code>命令用于Shell内置命令时（比如<code>cd</code>），将没有任何输出。</p><p><strong>help，man</strong></p><p><code>help</code>命令用于查看Shell内置命令的帮助信息，<code>man</code>命令用于查看可执行命令的帮助信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">help</span> <span class="token builtin class-name">cd</span>
$ <span class="token function">man</span> <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>man</code>里面的文档一共有8类，如果同一个命令，匹配多个文档，<code>man</code>命令总是返回第一个匹配。如果想看指定类型的文档，命令可以采用下面的形式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">man</span> <span class="token number">5</span> <span class="token function">passwd</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>export</strong></p><p><code>export</code>命令用于将当前进程的变量，输出到所有子进程。</p>`,452),t=[c];function d(o,p){return n(),a("div",null,t)}const u=s(l,[["render",d],["__file","progress.html.vue"]]);export{u as default};
