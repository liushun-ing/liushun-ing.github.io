import{_ as s,o as a,c as n,a as e}from"./app-79248646.js";const l={},i=e(`<h1 id="bash基础" tabindex="-1"><a class="header-anchor" href="#bash基础" aria-hidden="true">#</a> bash基础</h1><p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><h3 id="shell-的含义" tabindex="-1"><a class="header-anchor" href="#shell-的含义" aria-hidden="true">#</a> Shell 的含义</h3><p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p><p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</p><p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</p><p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p><p>查看版本</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">zsh</span> <span class="token parameter variable">--version</span>
<span class="token function">zsh</span> <span class="token number">5.9</span> <span class="token punctuation">(</span>x86_64-apple-darwin23.0<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="shell种类" tabindex="-1"><a class="header-anchor" href="#shell种类" aria-hidden="true">#</a> shell种类</h3><p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p><p>历史上，主要的 Shell 有下面这些。</p><ul><li>Bourne Shell（sh）</li><li>Bourne Again shell（bash）</li><li>C Shell（csh）</li><li>TENEX C Shell（tcsh）</li><li>Korn shell（ksh）</li><li>Z Shell（zsh）</li><li>Friendly Interactive Shell（fish）</li></ul><p>Bash 是目前最常用的 Shell。</p><p>下面的命令可以查看当前设备的默认 Shell。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>                      
/bin/zsh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当前正在使用的 Shell 不一定是默认 Shell。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">ps</span> 
  PID TTY           TIME CMD
<span class="token number">12280</span> ttys000    <span class="token number">0</span>:00.80 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
<span class="token number">51817</span> ttys001    <span class="token number">0</span>:00.15 <span class="token parameter variable">-zsh</span>
<span class="token number">12351</span> ttys002    <span class="token number">0</span>:00.61 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
<span class="token number">12411</span> ttys003    <span class="token number">0</span>:00.66 /bin/zsh <span class="token parameter variable">--login</span> <span class="token parameter variable">-i</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面的命令可以查看当前的 mac 系统安装的所有 Shell。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">cat</span> /etc/shells
<span class="token comment"># List of acceptable shells for chpass(1).</span>
<span class="token comment"># Ftpd will not allow users to connect who are not using</span>
<span class="token comment"># one of these shells.</span>

/bin/bash
/bin/csh
/bin/dash
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>chsh</code>命令，可以改变系统的默认 Shell。举例来说，要将默认 Shell 从 Bash 改成 Fish，首先要找出 Fish 可执行文件的位置。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">which</span> <span class="token function">bash</span>
/bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，使用<code>chsh</code>命令切换默认 Shell。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ chsh <span class="token parameter variable">-s</span> /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会将当前的默认 Shell 改成 bash。</p><h3 id="命令行环境" tabindex="-1"><a class="header-anchor" href="#命令行环境" aria-hidden="true">#</a> 命令行环境</h3><p>如果是不带有图形环境的 Linux 系统（比如专用于服务器的系统），启动后就直接是命令行环境。</p><p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p><p>所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p><p>不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p><h3 id="进入和退出" tabindex="-1"><a class="header-anchor" href="#进入和退出" aria-hidden="true">#</a> 进入和退出</h3><p>进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入<code>bash</code>命令启动 Bash。</p><p>退出 Bash 环境，可以使用<code>exit</code>命令，也可以同时按下<code>Ctrl + d</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">bash</span>
The default interactive shell is now zsh.
To update your account to use zsh, please run <span class="token variable"><span class="token variable">\`</span>chsh <span class="token parameter variable">-s</span> /bin/zsh<span class="token variable">\`</span></span><span class="token builtin class-name">.</span>
For <span class="token function">more</span> details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ <span class="token builtin class-name">pwd</span>
/Users/liushun
bash-3.2$ <span class="token builtin class-name">exit</span>
<span class="token builtin class-name">exit</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h2><h3 id="echo-命令" tabindex="-1"><a class="header-anchor" href="#echo-命令" aria-hidden="true">#</a> echo 命令</h3><p><code>echo</code>命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p><p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;&lt;HTML&gt;
    &lt;HEAD&gt;
          &lt;TITLE&gt;Page Title&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
          Page body.
    &lt;/BODY&gt;
&lt;/HTML&gt;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-n</code>参数</p><p>默认情况下，<code>echo</code>输出的文本末尾会有一个回车符。<code>-n</code>参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p><p><code>-e</code>参数</p><p><code>-e</code>参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符<code>\\n</code>）。如果不使用<code>-e</code>参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code>不解释它们，原样输出。</p><h3 id="命令格式" tabindex="-1"><a class="header-anchor" href="#命令格式" aria-hidden="true">#</a> 命令格式</h3><p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">command</span> <span class="token punctuation">[</span> arg1 <span class="token punctuation">..</span>. <span class="token punctuation">[</span> argN <span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，<code>command</code>是具体的命令或者一个可执行文件，<code>arg1 ... argN</code>是传递给命令的参数，它们是可选的。</p><p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如<code>-l</code>。同一个配置项往往有长和短两种形式，比如<code>-l</code>是短形式，<code>--list</code>是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p><p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> foo bar
<span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> foo <span class="token punctuation">\\</span>
bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="空格" tabindex="-1"><a class="header-anchor" href="#空格" aria-hidden="true">#</a> 空格</h3><p>Bash 使用空格（或 Tab 键）区分不同的参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">command</span> foo bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>foo</code>和<code>bar</code>之间有一个空格，所以 Bash 认为它们是两个参数。</p><p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p><h3 id="分号" tabindex="-1"><a class="header-anchor" href="#分号" aria-hidden="true">#</a> 分号</h3><p>分号（<code>;</code>）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">clear</span><span class="token punctuation">;</span> <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p><h3 id="命令的组合符-和" tabindex="-1"><a class="header-anchor" href="#命令的组合符-和" aria-hidden="true">#</a> 命令的组合符<code>&amp;&amp;</code>和<code>||</code></h3><p>除了分号，Bash 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ Command1 <span class="token operator">&amp;&amp;</span> Command2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令的意思是，只有<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ Command1 <span class="token operator">||</span> Command2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令的意思是，只有<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p><h3 id="type-命令" tabindex="-1"><a class="header-anchor" href="#type-命令" aria-hidden="true">#</a> type 命令</h3><p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？</p><p><code>type</code>命令用来判断命令的来源。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">type</span> <span class="token builtin class-name">echo</span>                 
<span class="token builtin class-name">echo</span> is a shell <span class="token builtin class-name">builtin</span>
➜  ~ <span class="token builtin class-name">type</span> <span class="token function">ls</span>  
<span class="token function">ls</span> is an <span class="token builtin class-name">alias</span> <span class="token keyword">for</span> <span class="token function">ls</span> <span class="token parameter variable">-G</span>
➜  ~ <span class="token builtin class-name">type</span> <span class="token function">ls</span> <span class="token parameter variable">-G</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>type</code>命令告诉我们，<code>echo</code>是内部命令。命令类型：别名（alias），关键词（keyword），函数（function），内置命令（builtin）和文件（file）</p><p><code>type</code>命令本身也是内置命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">type</span> <span class="token builtin class-name">type</span> 
<span class="token builtin class-name">type</span> is a shell <span class="token builtin class-name">builtin</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要查看一个命令的所有定义，可以使用<code>type</code>命令的<code>-a</code>参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">type</span> <span class="token parameter variable">-a</span> <span class="token builtin class-name">echo</span>
<span class="token builtin class-name">echo</span> is a shell <span class="token builtin class-name">builtin</span>
<span class="token builtin class-name">echo</span> is /bin/echo
➜  ~ <span class="token builtin class-name">type</span> <span class="token parameter variable">-a</span> <span class="token function">ls</span>  
<span class="token function">ls</span> is an <span class="token builtin class-name">alias</span> <span class="token keyword">for</span> <span class="token function">ls</span> <span class="token parameter variable">-G</span>
<span class="token function">ls</span> is /bin/ls
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码表示，<code>echo</code>命令即是内置命令，也有对应的外部程序。</p><h2 id="模式扩展" tabindex="-1"><a class="header-anchor" href="#模式扩展" aria-hidden="true">#</a> 模式扩展</h2><p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p><p>这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。</p><ul><li>波浪线扩展</li><li><code>?</code> 字符扩展</li><li><code>*</code> 字符扩展</li><li>方括号扩展</li><li>大括号扩展</li><li>变量扩展</li><li>子命令扩展</li><li>算术扩展</li></ul><p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。</p><p><code>globbing</code>这个词，来自于早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p><p>Bash 允许用户关闭扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">set</span> <span class="token parameter variable">-o</span> noglob
<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">set</span> <span class="token parameter variable">-f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面的命令可以重新打开扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">set</span> +o noglob
<span class="token comment"># 或者</span>
$ <span class="token builtin class-name">set</span> +f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="波浪线扩展" tabindex="-1"><a class="header-anchor" href="#波浪线扩展" aria-hidden="true">#</a> 波浪线扩展</h3><p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> ~
/Users/liushun
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>~/dir</code>表示扩展成主目录的某个子目录，<code>dir</code>是主目录里面的一个子目录名。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> ~/go 
/Users/liushun/go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>~user</code>表示扩展成用户<code>user</code>的主目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> ~root
/var/root
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。如果<code>~user</code>的<code>user</code>是不存在的用户名，则波浪号扩展不起作用。</p><p><code>~+</code>会扩展成当前所在的目录，等同于<code>pwd</code>命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> ~+/go
/Users/liushun/go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="字符扩展" tabindex="-1"><a class="header-anchor" href="#字符扩展" aria-hidden="true">#</a> <code>?</code> 字符扩展</h3><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>后面跟着三个字符的文件名。如果匹配多个字符，就需要多个<code>?</code>连用。</p><p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>➜  ~ echo hell~.go
hell~.go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>扩展没发生，原样输出。</p><h3 id="字符扩展-1" tabindex="-1"><a class="header-anchor" href="#字符扩展-1" aria-hidden="true">#</a> <code>*</code> 字符扩展</h3><p><code>*</code>字符代表文件路径里面的任意数量的字符，包括零个字符。</p><p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件）。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>➜  ~ echo .*      
.CFUserTextEncoding .DS_Store .TranslationPlugin .Trash .bash_history .bash_profile .cache .config .cups .dlv .docker .erlang.cookie .gitconfig .goctl .gradle .ipython .jetbrains.vmoptions.sh .jzero .lesshst .m2 .matplotlib .minio .mysql_history .npm .npmrc .oh-my-zsh .profile .rediscli_history .ssh .viminfo .vscode .zcompdump-liushun-5.9 .zcompdump-liushun-5.9.zwc .zprofile .zprofile.pysave .zsh_history .zsh_sessions .zshrc .zshrc.pre-oh-my-zsh
➜  ~ echo *   
Applications Desktop Documents Downloads Library Movies Music Pictures Postman Public ScreenPal default.etcd dump.rdb go logs nacos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>*</code>字符扩展也属于文件名扩展，只有文件确实存在的前提下才会扩展</strong>。如果文件不存在，就会原样输出。</p><p><code>*</code>只匹配当前目录，不会匹配子目录。文本文件在子目录，必须写成<code>*/*.xxx</code>。有几层子目录，就必须写几层星号。</p><p>Bash 4.0 引入了一个参数<code>globstar</code>，当该参数打开时，允许<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>可以匹配顶层的文本文件和任意深度子目录的文本文件。</p><h3 id="方括号扩展" tabindex="-1"><a class="header-anchor" href="#方括号扩展" aria-hidden="true">#</a> 方括号扩展</h3><p>方括号扩展的形式是<code>[...]</code>，只有<strong>文件确实存在的前提下才会扩展</strong>。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。</p><p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
zsh: no matches found: <span class="token punctuation">[</span>ab<span class="token punctuation">]</span>.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>方括号扩展变体：<code>[^...]</code>。它们表示匹配不在方括号里面的字符。比如，<code>[^abc]</code>表示匹配除了<code>a</code>、<code>b</code>、<code>c</code>以外的字符。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">ls</span> <span class="token punctuation">[</span>^ab<span class="token punctuation">]</span>.txt
zsh: no matches found: <span class="token punctuation">[</span>^ab<span class="token punctuation">]</span>.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="start-end-扩展" tabindex="-1"><a class="header-anchor" href="#start-end-扩展" aria-hidden="true">#</a> [start-end] 扩展</h3><p>方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code>等同于<code>[abc]</code>，<code>[0-9]</code>匹配<code>[0123456789]</code>。</p><p>下面是一些常用简写的例子。</p><ul><li><code>[a-z]</code>：所有小写字母。</li><li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li><li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li><li><code>[abc]*</code>：所有以<code>a</code>、<code>b</code>、<code>c</code>字符之一开头的文件名。</li><li><code>program.[co]</code>：文件<code>program.c</code>与文件<code>program.o</code>。</li><li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以<code>BACKUP.</code>开头，后面是三个数字的文件名。</li></ul><p>这种简写形式有一个否定形式<code>[^start-end]</code>，表示匹配不属于这个范围的字符。</p><h3 id="大括号扩展" tabindex="-1"><a class="header-anchor" href="#大括号扩展" aria-hidden="true">#</a> 大括号扩展</h3><p>大括号扩展<code>{...}</code>表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code>扩展成<code>1 2 3</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span><span class="token number">1,2</span>,4<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意，大括号扩展不是文件名扩展</strong>。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>➜  ~ ls [123].txt
zsh: no matches found: [123].txt
➜  ~ ls {1,2,3}.txt
ls: 1.txt: No such file or directory
ls: 2.txt: No such file or directory
ls: 3.txt: No such file or directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，即使不存在对应的文件，<code>{1,2,3}</code>依然扩展成三个文件名，导致<code>ls</code>命令报了三个错误。</p><p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效，会被认为是参数。</p><p>逗号前面可以没有值，表示扩展的第一项为空。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cp</span> a.log<span class="token punctuation">{</span>,.bak<span class="token punctuation">}</span> <span class="token comment"># 等同于</span>
$ <span class="token function">cp</span> a.log a.log.bak
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号可以嵌套。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>j<span class="token punctuation">{</span>p,pe<span class="token punctuation">}</span>g,png<span class="token punctuation">}</span>jpg
jpgjpg jpegjpg pngjpg
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>cat,dog<span class="token punctuation">}</span>
<span class="token function">cat</span> dog
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>由于大括号扩展<code>{...}</code>不是文件名扩展，所以它总是会扩展的</strong>。这与方括号扩展<code>[...]</code>完全不同，如果匹配的文件不存在，方括号就不会扩展。</p><h3 id="start-end-扩展-1" tabindex="-1"><a class="header-anchor" href="#start-end-扩展-1" aria-hidden="true">#</a> {start..end} 扩展</h3><p>大括号扩展有一个简写形式<code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code>可以扩展成26个小写英文字母。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>a<span class="token punctuation">..</span>c<span class="token punctuation">}</span>
a b c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式支持逆序。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">..</span><span class="token number">1</span><span class="token punctuation">}</span>
<span class="token number">5</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>a1<span class="token punctuation">..</span>3c<span class="token punctuation">}</span>
<span class="token punctuation">{</span>a1<span class="token punctuation">..</span>3c<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> .<span class="token punctuation">{</span>mp<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">}</span>,m4<span class="token punctuation">{</span>a,b,p,v<span class="token punctuation">}</span><span class="token punctuation">}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个写法的另一个常见用途，是直接用于<code>for</code>循环。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">4</span><span class="token punctuation">}</span>
<span class="token keyword">do</span>
  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span>
<span class="token keyword">done</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果整数前面有前导<code>0</code>，扩展输出的每一项都有前导<code>0</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>01<span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">}</span>
01 02 03 04 05
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">8</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">}</span>
<span class="token number">0</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">8</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>多个简写形式连用，会有循环处理的效果。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">{</span>a<span class="token punctuation">..</span>c<span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="变量扩展" tabindex="-1"><a class="header-anchor" href="#变量扩展" aria-hidden="true">#</a> 变量扩展</h3><p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>
/bin/zsh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变量名除了放在美元符号后面，也可以放在<code>\${}</code>里面。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">\${<span class="token environment constant">SHELL</span>}</span>
/bin/zsh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="子命令扩展" tabindex="-1"><a class="header-anchor" href="#子命令扩展" aria-hidden="true">#</a> 子命令扩展</h3><p><code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>
<span class="token number">2024</span>年10月13日 星期日 <span class="token number">17</span>时17分07秒 CST
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p><p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">date</span><span class="token variable">\`</span></span>
<span class="token number">2024</span>年10月13日 星期日 <span class="token number">17</span>时17分24秒 CST
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$(...)</code>可以嵌套，比如<code>$(ls $(pwd))</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token punctuation">$(</span>pwd<span class="token punctuation">)</span><span class="token variable">)</span></span>  
Applications Desktop Documents Downloads Library Movies Music Pictures Postman Public ScreenPal default.etcd dump.rdb go logs nacos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="算术扩展" tabindex="-1"><a class="header-anchor" href="#算术扩展" aria-hidden="true">#</a> 算术扩展</h3><p><code>$((...))</code>可以扩展成整数运算的结果</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token variable">))</span></span>
<span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="字符类" tabindex="-1"><a class="header-anchor" href="#字符类" aria-hidden="true">#</a> 字符类</h3><p><code>[[:class:]]</code>表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p><ul><li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li><li><code>[[:alpha:]]</code>：匹配任意英文字母</li><li><code>[[:blank:]]</code>：空格和 Tab 键。</li><li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li><li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li><li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li><li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li><li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li><li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li><li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li><li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li><li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li></ul><p>请看下面的例子。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>:upper:<span class="token punctuation">]</span><span class="token punctuation">]</span>*
Applications Desktop Documents Downloads Library Movies Music Pictures Postman Public ScreenPal
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令输出所有大写字母开头的文件名。</p><p>字符类的第一个方括号后面，可以加上<code>^</code>，表示否定。比如，<code>[^[:digit:]]</code>匹配所有非数字。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">[</span>^<span class="token punctuation">[</span>:digit:<span class="token punctuation">]</span><span class="token punctuation">]</span>*
Applications Desktop Documents Downloads Library Movies Music Pictures Postman Public ScreenPal default.etcd dump.rdb go logs nacos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出.</p><h2 id="引号和转义" tabindex="-1"><a class="header-anchor" href="#引号和转义" aria-hidden="true">#</a> 引号和转义</h2><p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p><h3 id="转义" tabindex="-1"><a class="header-anchor" href="#转义" aria-hidden="true">#</a> 转义</h3><p>某些字符在 Bash 里面有特殊含义（比如<code>$</code>、<code>&amp;</code>、<code>*</code>）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">$date</span>

➜  ~ <span class="token builtin class-name">echo</span> <span class="token punctuation">\\</span><span class="token variable">$date</span>
<span class="token variable">$date</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，输出<code>$date</code>不会有任何结果，因为<code>$</code>是一个特殊字符。</p><p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。</p><p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p><ul><li><code>\\a</code>：响铃</li><li><code>\\b</code>：退格</li><li><code>\\n</code>：换行</li><li><code>\\r</code>：回车</li><li><code>\\t</code>：制表符</li></ul><p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> a<span class="token punctuation">\\</span>tb
atb
➜  ~ <span class="token builtin class-name">echo</span> a<span class="token punctuation">\\</span><span class="token punctuation">\\</span>tb
a	b
➜  ~ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">&quot;a<span class="token entity" title="\\t">\\t</span>b&quot;</span>
a	b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">mv</span> <span class="token punctuation">\\</span>
/path/to/foo <span class="token punctuation">\\</span>
/path/to/bar
<span class="token comment"># 等同于</span>
$ <span class="token function">mv</span> /path/to/foo /path/to/bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</strong></p><h3 id="单引号" tabindex="-1"><a class="header-anchor" href="#单引号" aria-hidden="true">#</a> 单引号</h3><p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p><p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（<code>*</code>）、美元符号（<code>$</code>）、反斜杠（<code>\\</code>）等。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&#39;$((2+2))&#39;</span>
<span class="token variable"><span class="token variable">$((</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span><span class="token variable">))</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p><p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（<code>$</code>），然后再对里层的单引号转义。</p><p>不过，更合理的方法是改在双引号之中使用单引号。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">$&#39;it\\&#39;s&#39;</span>
it<span class="token string">&#39;s
➜  ~ echo &quot;it&#39;</span>s&quot;
it&#39;s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="双引号" tabindex="-1"><a class="header-anchor" href="#双引号" aria-hidden="true">#</a> 双引号</h3><p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外：美元符号（<code>$</code>）、反引号（\`\` <code>）和反斜杠（</code>\`）。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&quot;*&quot;</span>
*
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，通配符<code>*</code>放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token environment constant">$SHELL</span>&quot;</span>
/bin/zsh
➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">\`</span><span class="token function">date</span><span class="token variable">\`</span></span>&quot;</span>
<span class="token number">2024</span>年10月13日 星期日 <span class="token number">17</span>时32分18秒 CST
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&quot;I&#39;d say: <span class="token entity" title="\\&quot;">\\&quot;</span>hello! <span class="token entity" title="\\&quot;">\\&quot;</span>&quot;</span>
I<span class="token string">&#39;d say: &quot;hello! &quot;
➜  ~ echo &quot;I&#39;</span>d say: <span class="token punctuation">\\</span>&quot;hello<span class="token operator">!</span><span class="token punctuation">\\</span>&quot;&quot; 
zsh: event not found: <span class="token punctuation">\\</span>
<span class="token comment"># 注意感叹号不能乱用</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p><p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&quot;hello
world&quot;</span>
hello
world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code>命令会将换行符原样输出，显示的时候正常解释为换行。</p><p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> <span class="token string">&quot;two words.txt&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>two words.txt</code>是一个包含空格的文件名，否则就会被 Bash 当作两个文件。双引号会原样保存多余的空格。</p><p>双引号还有一个作用，就是保存原始命令的输出格式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>
十月 <span class="token number">2024</span> 日 一 二 三 四 五 六 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span> <span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span> <span class="token number">27</span> <span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">cal</span><span class="token variable">)</span></span>&quot;</span>

      十月 <span class="token number">2024</span>         
日 一 二 三 四 五 六  
       <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">5</span>  
 <span class="token number">6</span>  <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span>  
<span class="token number">13</span> <span class="token number">14</span> <span class="token number">15</span> <span class="token number">16</span> <span class="token number">17</span> <span class="token number">18</span> <span class="token number">19</span>  
<span class="token number">20</span> <span class="token number">21</span> <span class="token number">22</span> <span class="token number">23</span> <span class="token number">24</span> <span class="token number">25</span> <span class="token number">26</span>  
<span class="token number">27</span> <span class="token number">28</span> <span class="token number">29</span> <span class="token number">30</span> <span class="token number">31</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，如果<code>$(cal)</code>不放在双引号之中，<code>echo</code>就会将所有结果以单行输出，丢弃了所有原始的格式。</p><h3 id="here-文档" tabindex="-1"><a class="header-anchor" href="#here-文档" aria-hidden="true">#</a> Here 文档</h3><p>Here 文档（here document）是一种输入多行字符串的方法，它的格式分成开始标记（<code>&lt;&lt; token</code>）和结束标记（<code>token</code>）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p><p>Here 文档内部会发生变量替换和通配符扩展，但是双引号和单引号都失去语法作用，变成了普通字符。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">&#39;hello&#39;</span>    
➜  ~ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> _e_     
heredoc<span class="token operator">&gt;</span> <span class="token variable">$foo</span>         
heredoc<span class="token operator">&gt;</span> <span class="token string">&quot;<span class="token variable">$foo</span>&quot;</span>       
heredoc<span class="token operator">&gt;</span> <span class="token string">&#39;$foo&#39;</span>
heredoc<span class="token operator">&gt;</span> _e_
hello
<span class="token string">&quot;hello&quot;</span>
<span class="token string">&#39;hello&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不希望发生变量替换和通配符扩展，可以把 Here 文档的开始标记放在单引号之中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#39;_e_&#39;
$foo
&quot;$foo&quot;
&#39;$foo&#39;
_e_</span>
<span class="token variable">$foo</span>
<span class="token string">&quot;<span class="token variable">$foo</span>&quot;</span>
<span class="token string">&#39;$foo&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令。Here 文档相当于<code>echo</code>命令的重定向。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">command</span> <span class="token operator">&lt;&lt;</span> <span class="token string">token  
string
token</span> <span class="token comment"># 等同于</span>
$ <span class="token builtin class-name">echo</span> string <span class="token operator">|</span> <span class="token builtin class-name">command</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用 Here 文档作为参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token operator">&lt;&lt;</span> <span class="token string">_example_
hello
_example_</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token builtin class-name">echo</span> <span class="token number">1</span>  
<span class="token builtin class-name">echo</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子不会有任何输出，因为 Here 文档对于<code>echo</code>命令无效。可以看到对于echo来说后面跟的全都是算作字符串</p><p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p><blockquote><p><strong>变体</strong></p></blockquote><p>Here 文档还有一个变体，叫做 <strong>Here 字符串（Here string</strong>），使用三个小于号（<code>&lt;&lt;&lt;</code>）表示。它的作用是将字符串通过标准输入，传递给命令。</p><p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如<code>cat</code>命令接受标准输入传入的字符串。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">&#39;hi there&#39;</span><span class="token comment"># 等同于</span>
$ hi there
$ <span class="token builtin class-name">echo</span> <span class="token string">&#39;hi there&#39;</span> <span class="token operator">|</span> <span class="token function">cat</span>
➜  ~ <span class="token function">cat</span> <span class="token string">&#39;hi there&#39;</span>
cat: hi there: No such <span class="token function">file</span> or directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。如果直接将字符串放在命令后面，会被当作文件名。</p><h2 id="bash变量" tabindex="-1"><a class="header-anchor" href="#bash变量" aria-hidden="true">#</a> Bash变量</h2><p>Bash 变量分成环境变量和自定义变量两类。</p><p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。<code>env</code>命令或<code>printenv</code>命令，可以显示所有环境变量。</p><p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p><p>注意，Bash 变量名区分大小写，<code>HOME</code>和<code>home</code>是两个不同的变量。</p><p>查看单个环境变量的值，可以使用<code>printenv</code>命令或<code>echo</code>命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">printenv</span> <span class="token environment constant">PATH</span>
$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>printenv</code>命令后面的变量名，不用加前缀<code>$</code>。</p><p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p><p><code>set</code>命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。</p><h3 id="创建变量" tabindex="-1"><a class="header-anchor" href="#创建变量" aria-hidden="true">#</a> 创建变量</h3><p>用户创建变量的时候，变量名必须遵守下面的规则。</p><ul><li>字母、数字和下划线字符组成。</li><li>第一个字符必须是一个字母或一个下划线，不能是数字。</li><li>不允许出现空格和标点符号。</li></ul><p>变量声明的语法如下。<code>variable=value</code>，等号左边是变量名，右边是变量。注意，等号两边不能有空格。如果变量的值包含空格，则必须将值放在引号中。Bash 没有数据类型的概念，所有的变量值都是字符串。</p><p>下面是一些自定义变量的例子。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">a</span><span class="token operator">=</span>z                     <span class="token comment"># 变量 a 赋值为字符串 z</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token string">&quot;a string&quot;</span>            <span class="token comment"># 变量值包含空格，就必须放在引号里面</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token string">&quot;a string and <span class="token variable">$b</span>&quot;</span>     <span class="token comment"># 变量值可以引用其他变量的值</span>
<span class="token assign-left variable">d</span><span class="token operator">=</span><span class="token string">&quot;<span class="token entity" title="\\t">\\t</span><span class="token entity" title="\\t">\\t</span>a string<span class="token entity" title="\\n">\\n</span>&quot;</span>      <span class="token comment"># 变量值可以使用转义字符</span>
<span class="token assign-left variable">e</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-l</span> foo.txt<span class="token variable">)</span></span>      <span class="token comment"># 变量值可以是命令的执行结果</span>
<span class="token assign-left variable">f</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token variable">))</span></span>            <span class="token comment"># 变量值可以是数学运算的结果</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p><h3 id="读变量" tabindex="-1"><a class="header-anchor" href="#读变量" aria-hidden="true">#</a> 读变量</h3><p>读取变量的时候，直接在变量名前加上<code>$</code>就可以了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
$ bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每当 Shell 看到以<code>$</code>开头的单词时，就会尝试读取这个变量名对应的值。如果变量不存在，Bash 不会报错，而会输出空字符。</p><p>读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如<code>$a</code>也可以写成<code>\${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p><h3 id="删除变量" tabindex="-1"><a class="header-anchor" href="#删除变量" aria-hidden="true">#</a> 删除变量</h3><p><code>unset</code>命令用来删除一个变量。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">unset</span> NAME
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。所以，删除一个变量，也可以将这个变量设成空字符串。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token string">&#39;&#39;</span>
$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两种写法，都是删除了变量<code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p><h3 id="输出变量-export-命令" tabindex="-1"><a class="header-anchor" href="#输出变量-export-命令" aria-hidden="true">#</a> 输出变量，export 命令</h3><p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用<code>export</code>命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p><p><code>export</code>命令用来向子 Shell 输出变量。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">NAME</span><span class="token operator">=</span>foo
<span class="token builtin class-name">export</span> NAME
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令输出了变量<code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">export</span> <span class="token assign-left variable">NAME</span><span class="token operator">=</span>value
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量<code>$NAME</code>。子 Shell 如果修改继承的变量，不会影响父 Shell。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">export</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span>bar
➜  ~ <span class="token function">bash</span>

The default interactive shell is now zsh.
To update your account to use zsh, please run <span class="token variable"><span class="token variable">\`</span>chsh <span class="token parameter variable">-s</span> /bin/zsh<span class="token variable">\`</span></span><span class="token builtin class-name">.</span>
For <span class="token function">more</span> details, please visit https://support.apple.com/kb/HT208050.
bash-3.2$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
bar
bash-3.2$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>baz
bash-3.2$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
baz
bash-3.2$ <span class="token builtin class-name">exit</span>
<span class="token builtin class-name">exit</span>
➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>     
bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="特殊变量" tabindex="-1"><a class="header-anchor" href="#特殊变量" aria-hidden="true">#</a> 特殊变量</h3><p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p><p>（1）<code>$?</code></p><p><code>$?</code>为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是<code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">ls</span> doesnotexist
ls: doesnotexist: No such <span class="token function">file</span> or directory
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>ls</code>命令查看一个不存在的文件，导致报错。<code>$?</code>为1，表示上一个命令执行失败。</p><p>（2）<code>$$</code></p><p><code>$$</code>为当前 Shell 的进程 ID。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">10662</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个特殊变量可以用来命名临时文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">LOGFILE</span><span class="token operator">=</span>/tmp/output_log.<span class="token variable">$$</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（3）<code>$_</code></p><p><code>$_</code>为上一个命令的最后一个参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">grep</span> dictionary /usr/share/dict/wordsdictionary
$ <span class="token builtin class-name">echo</span> <span class="token variable">$_</span>
/usr/share/dict/words
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）<code>$!</code></p><p><code>$!</code>为最近一个后台执行的异步命令的进程 ID。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ firefox <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">11064</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$!</span>
<span class="token number">11064</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>firefox</code>是后台运行的命令，<code>$!</code>返回该命令的进程 ID。</p><p>（5）<code>$0</code></p><p><code>$0</code>为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>  
<span class="token parameter variable">-zsh</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（6）<code>$-</code></p><p><code>$-</code>为当前 Shell 的启动参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> $-
569JNRXZghiklms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>（7）<code>$@</code>和<code>$#</code></p><p><code>$@</code>和<code>$#</code>表示脚本的参数数量。</p><h3 id="变量的默认值" tabindex="-1"><a class="header-anchor" href="#变量的默认值" aria-hidden="true">#</a> 变量的默认值</h3><p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">\${varname<span class="token operator">:-</span>word}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则<strong>返回<code>word</code></strong>。它的目的是返回一个默认值，比如<code>\${count:-0}</code>表示变量<code>count</code>不存在时返回<code>0</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">\${varname<span class="token operator">:=</span>word}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则<strong>将它设为<code>word</code>，并且返回<code>word</code></strong>。它的目的是设置变量的默认值，比如<code>\${count:=0}</code>表示变量<code>count</code>不存在时返回<code>0</code>，且将<code>count</code>设为<code>0</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">\${varname<span class="token operator">:+</span>word}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法的含义是，如果变量名存在且不为空，则返回<code>word</code>，<strong>否则返回空值</strong>。它的目的是测试变量是否存在，比如<code>\${count:+1}</code>表示变量<code>count</code>存在时返回<code>1</code>（表示<code>true</code>），否则返回空值。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">\${varname<span class="token operator">:?</span>message}</span>  
zsh: varname: message
➜  ~ <span class="token builtin class-name">echo</span> <span class="token variable">\${varname<span class="token operator">:?</span>}</span>       
zsh: varname: parameter not <span class="token builtin class-name">set</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，<strong>则返回它的值，否则打印出<code>varname: message</code>，并中断脚本的执行</strong>。如果省略了<code>message</code>，则输出默认的信息“parameter not set.”。它的目的是防止变量未定义。</p><p>上面四种语法如果用在脚本中，变量名的部分可以用到数字<code>1</code>到<code>9</code>，表示脚本的参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">filename</span><span class="token operator">=</span><span class="token variable">\${1<span class="token operator">:?</span>&quot;filename missing.&quot;}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码出现在脚本中，<code>1</code>表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p><h3 id="declare-命令" tabindex="-1"><a class="header-anchor" href="#declare-命令" aria-hidden="true">#</a> declare 命令</h3><p><code>declare</code>命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">declare</span> OPTION <span class="token assign-left variable">VARIABLE</span><span class="token operator">=</span>value
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>declare</code>命令的主要参数（OPTION）如下。</p><ul><li><code>-a</code>：声明数组变量。</li><li><code>-f</code>：输出所有函数定义。</li><li><code>-i</code>：声明整数变量。</li><li><code>-l</code>：声明变量为小写字母，会自动转换。</li><li><code>-p</code>：查看变量信息。</li><li><code>-r</code>：声明只读变量。</li><li><code>-u</code>：声明变量为大写字母。</li><li><code>-x</code>：该变量输出为环境变量，<code>-x</code>参数等同于<code>export</code>命令，可以输出一个变量为子 Shell 的环境变量。</li></ul><p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p><p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p><h3 id="readonly-命令" tabindex="-1"><a class="header-anchor" href="#readonly-命令" aria-hidden="true">#</a> readonly 命令</h3><p><code>readonly</code>命令等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">readonly</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>
 liushun@liushun  ~  <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">2</span>                            
zsh: read-only variable: foo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，更改只读变量<code>foo</code>会报错，命令执行失败。</p><p><code>readonly</code>命令有三个参数。</p><ul><li><code>-f</code>：声明的变量为函数名。</li><li><code>-p</code>：打印出所有的只读变量。</li><li><code>-a</code>：声明的变量为数组。</li></ul><h3 id="let-命令" tabindex="-1"><a class="header-anchor" href="#let-命令" aria-hidden="true">#</a> let 命令</h3><p><code>let</code>命令声明变量时，可以直接执行算术表达式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">let</span> <span class="token assign-left variable">foo</span><span class="token operator">=</span><span class="token number">1</span>+2
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>let</code>命令可以直接计算<code>1 + 2</code>。</p><p><code>let</code>命令的参数表达式如果包含空格，就需要使用引号。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">let</span> <span class="token string">&quot;foo = 1 + 2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">let</span> <span class="token string">&quot;v1 = 1&quot;</span> <span class="token string">&quot;v2 = v1++&quot;</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$v1</span>,<span class="token variable">$v2</span>
<span class="token number">2,1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="字符串操作" tabindex="-1"><a class="header-anchor" href="#字符串操作" aria-hidden="true">#</a> 字符串操作</h2><h3 id="长度" tabindex="-1"><a class="header-anchor" href="#长度" aria-hidden="true">#</a> 长度</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token assign-left variable">foo</span><span class="token operator">=</span>hello
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${<span class="token operator">#</span>foo}</span>
<span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号<code>{}</code>是必需的，否则 Bash 会将<code>$#</code>理解成脚本的参数个数，将变量名理解成文本。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable">$#</span>myvar
0myvar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="子字符串" tabindex="-1"><a class="header-anchor" href="#子字符串" aria-hidden="true">#</a> 子字符串</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">\${varname<span class="token operator">:</span>offset<span class="token operator">:</span>length}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 报错</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">\${&quot;hello&quot;<span class="token operator">:</span>2<span class="token operator">:</span>3}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果省略<code>length</code>，则从位置<code>offset</code>开始，一直返回到字符串的结尾。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span>2<span class="token operator">:</span>3}</span> 
llo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code>offset</code>为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与<code>\${variable:-word}</code>的变量的设置默认值语法混淆。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:</span>3}</span>
lo
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:-</span>3}</span>
zsh: substring expression: <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">3</span>
 ✘ liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:-</span>1}</span>
l
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:-</span>2}</span>

 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:</span>0}</span> 

 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:</span>1}</span>
l
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">:</span> -2<span class="token operator">:</span>3}</span>
lo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="搜索和替换" tabindex="-1"><a class="header-anchor" href="#搜索和替换" aria-hidden="true">#</a> 搜索和替换</h3><p><strong>（1）字符串头部的模式匹配。</strong></p><p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化.。如果匹配不成功，则返回原始字符串。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="token comment"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">\${variable<span class="token operator">#</span>pattern}</span>
<span class="token comment"># 如果 pattern 匹配变量 variable 的开头，</span>
<span class="token comment"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">\${variable<span class="token operator">##</span>pattern}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匹配模式<code>pattern</code>可以使用<code>*</code>、<code>?</code>、<code>[]</code>等通配符。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${myPath<span class="token operator">#</span><span class="token operator">/</span>*<span class="token operator">/</span>}</span> 
cam/book/long.file.name
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${myPath<span class="token operator">##</span><span class="token operator">/</span>*<span class="token operator">/</span>}</span>
long.file.name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，匹配的模式是<code>/*/</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>/home/</code>，最长匹配是<code>/home/cam/book/</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">&quot;555-456-1414&quot;</span>
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${phone<span class="token operator">/</span>5?4<span class="token operator">/</span>-}</span>
<span class="token number">55</span>-56-1414
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 模式必须出现在字符串的开头\${variable/#pattern/string}</span>
<span class="token assign-left variable">foo</span><span class="token operator">=</span>JPG.JPG
liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${foo<span class="token operator">/</span><span class="token operator">#</span>JPG<span class="token operator">/</span>jpg}</span>
jpg.JPG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，被替换的<code>JPG</code>必须出现在字符串头部，所以返回<code>jpg.JPG</code>。</p><p><strong>（2）字符串尾部的模式匹配。</strong></p><p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="token comment"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">\${variable<span class="token operator">%</span>pattern}</span>
<span class="token comment"># 如果 pattern 匹配变量 variable 的结尾，</span>
<span class="token comment"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span>
<span class="token variable">\${variable<span class="token operator">%%</span>pattern}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 模式必须出现在字符串的结尾
\${variable/%pattern/string}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（3）任意位置的模式匹配。</strong></p><p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="token comment"># 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配</span>
<span class="token variable">\${variable<span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span>
<span class="token comment"># 如果 pattern 匹配变量 variable 的一部分，</span>
<span class="token comment"># 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换</span>
<span class="token variable">\${variable<span class="token operator">/</span><span class="token operator">/</span>pattern<span class="token operator">/</span>string}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~   <span class="token assign-left variable">ppppath</span><span class="token operator">=</span>/home/cam/foo/foo.name
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${ppppath<span class="token operator">/</span>foo<span class="token operator">/</span>bar}</span>
/home/cam/bar/foo.name
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable">\${ppppath<span class="token operator">/</span><span class="token operator">/</span>foo<span class="token operator">/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>模式部分可以使用通配符。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">phone</span><span class="token operator">=</span><span class="token string">&quot;555-456-1414&quot;</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">\${phone<span class="token operator">/</span>5?4<span class="token operator">/</span>-}</span>
<span class="token number">55</span>-56-1414
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果省略了<code>string</code>部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p><h2 id="bash的算术运算" tabindex="-1"><a class="header-anchor" href="#bash的算术运算" aria-hidden="true">#</a> Bash的算术运算</h2><h3 id="算术表达式" tabindex="-1"><a class="header-anchor" href="#算术表达式" aria-hidden="true">#</a> 算术表达式</h3><p><code>((...))</code>语法可以进行整数的算术运算。<code>((...))</code>会自动忽略内部的空格。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token variable"><span class="token punctuation">((</span>foo <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是<code>0</code>，命令就算执行成功。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token variable"><span class="token punctuation">((</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token punctuation">))</span></span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
<span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要读取算术运算的结果，需要在<code>((...))</code>前面加上美元符号<code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p><p><code>((...))</code>语法支持的算术运算符如下。</p><ul><li><code>+</code>：加法</li><li><code>-</code>：减法</li><li><code>*</code>：乘法</li><li><code>/</code>：除法（整除）</li><li><code>%</code>：余数</li><li><code>**</code>：指数</li><li><code>++</code>：自增运算（前缀或后缀）</li><li><code>--</code>：自减运算（前缀或后缀）</li></ul><p>注意，除法运算符的返回结果总是整数。<code>$((...))</code>内部可以用圆括号改变运算顺序。<code>$((...))</code>结构可以嵌套。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span><span class="token variable">))</span></span>           
<span class="token number">2</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token variable">$((</span><span class="token number">5</span><span class="token operator">**</span><span class="token number">2</span><span class="token variable">))</span></span> * <span class="token number">3</span><span class="token punctuation">))</span>
<span class="token number">75</span>
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">1.5</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span>
<span class="token number">2.5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$((...))</code>的圆括号之中，不需要在变量名之前加上<code>$</code>，不过加上也不报错。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>$number<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span>
<span class="token number">3</span>
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>number<span class="token operator">+</span><span class="token number">1</span><span class="token variable">))</span></span> 
<span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在<code>$((...))</code>里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">foo</span><span class="token operator">=</span>hello
$ <span class="token assign-left variable">hello</span><span class="token operator">=</span><span class="token number">3</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span> foo <span class="token operator">+</span> <span class="token number">2</span> <span class="token variable">))</span></span>
<span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数值的进制" tabindex="-1"><a class="header-anchor" href="#数值的进制" aria-hidden="true">#</a> 数值的进制</h3><p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p><ul><li><code>number</code>：没有任何特殊表示法的数字是十进制数（以10为底）。</li><li><code>0xnumber</code>：十六进制数。</li><li><code>base#number</code>：<code>base</code>进制的数。</li></ul><p>下面是一些例子。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">0xff</span><span class="token variable">))</span></span>
<span class="token number">255</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span><span class="token number">2</span>#<span class="token number">11111111</span><span class="token variable">))</span></span>
<span class="token number">255</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="位运算" tabindex="-1"><a class="header-anchor" href="#位运算" aria-hidden="true">#</a> 位运算</h3><p><code>$((...))</code>支持以下的二进制位运算符。</p><ul><li><code>&lt;&lt;</code>：位左移运算，把一个数字的所有位向左移动指定的位。</li><li><code>&gt;&gt;</code>：位右移运算，把一个数字的所有位向右移动指定的位。</li><li><code>&amp;</code>：位的“与”运算，对两个数字的所有位执行一个<code>AND</code>操作。</li><li><code>|</code>：位的“或”运算，对两个数字的所有位执行一个<code>OR</code>操作。</li><li><code>~</code>：位的“否”运算，对一个数字的所有位取反。</li><li><code>!</code>：逻辑“否”运算</li><li><code>^</code>：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。</li></ul><h3 id="逻辑运算" tabindex="-1"><a class="header-anchor" href="#逻辑运算" aria-hidden="true">#</a> 逻辑运算</h3><p><code>$((...))</code>支持以下的逻辑运算符。</p><ul><li><code>&lt;</code>：小于</li><li><code>&gt;</code>：大于</li><li><code>&lt;=</code>：小于或相等</li><li><code>&gt;=</code>：大于或相等</li><li><code>==</code>：相等</li><li><code>!=</code>：不相等</li><li><code>&amp;&amp;</code>：逻辑与</li><li><code>||</code>：逻辑或</li><li><code>expr1?expr2:expr3</code>：三元条件运算符。若表达式<code>expr1</code>的计算结果为非零值（算术真），则执行表达式<code>expr2</code>，否则执行表达式<code>expr3</code>。</li></ul><h3 id="赋值运算" tabindex="-1"><a class="header-anchor" href="#赋值运算" aria-hidden="true">#</a> 赋值运算</h3><p>算术表达式<code>$((...))</code>可以执行赋值运算。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token variable">))</span></span>
<span class="token number">1</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$a</span>
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>a=1</code>对变量<code>a</code>进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p><p><code>$((...))</code>支持的赋值运算符，有以下这些。</p><ul><li><code>parameter = value</code>：简单赋值。</li><li><code>parameter += value</code>：等价于<code>parameter = parameter + value</code>。</li><li><code>parameter -= value</code>：等价于<code>parameter = parameter – value</code>。</li><li><code>parameter *= value</code>：等价于<code>parameter = parameter * value</code>。</li><li><code>parameter /= value</code>：等价于<code>parameter = parameter / value</code>。</li><li><code>parameter %= value</code>：等价于<code>parameter = parameter % value</code>。</li><li><code>parameter &lt;&lt;= value</code>：等价于<code>parameter = parameter &lt;&lt; value</code>。</li><li><code>parameter &gt;&gt;= value</code>：等价于<code>parameter = parameter &gt;&gt; value</code>。</li><li><code>parameter &amp;= value</code>：等价于<code>parameter = parameter &amp; value</code>。</li><li><code>parameter |= value</code>：等价于<code>parameter = parameter | value</code>。</li><li><code>parameter ^= value</code>：等价于<code>parameter = parameter ^ value</code>。</li></ul><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ echo $(( a&lt;1 ? (a+=1) : (a-=1) ))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="求值运算" tabindex="-1"><a class="header-anchor" href="#求值运算" aria-hidden="true">#</a> 求值运算</h3><p>逗号<code>,</code>在<code>$((...))</code>内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>foo <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token variable">))</span></span>
<span class="token number">12</span>
$ <span class="token builtin class-name">echo</span> <span class="token variable">$foo</span>
<span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值<code>12</code>。</p><h3 id="expr-命令" tabindex="-1"><a class="header-anchor" href="#expr-命令" aria-hidden="true">#</a> expr 命令</h3><p><code>expr</code>命令支持算术运算，可以不使用<code>((...))</code>语法。</p><p><code>expr</code>命令支持变量替换。</p><p><code>expr</code>命令不支持非整数参数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token function">expr</span> <span class="token number">3</span> + <span class="token number">2</span>
<span class="token number">5</span>
 liushun@liushun  ~  <span class="token function">expr</span> <span class="token variable">$foo</span> + <span class="token number">25</span>
<span class="token number">28</span>
 liushun@liushun  ~  <span class="token function">expr</span> <span class="token number">3.5</span> + <span class="token number">2</span>
expr: not a decimal number: <span class="token string">&#39;3.5&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bash-行操作" tabindex="-1"><a class="header-anchor" href="#bash-行操作" aria-hidden="true">#</a> Bash 行操作</h2><p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p><p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键，<code>set -o vi</code>。</p><p>下面的命令可以改回 Emacs 快捷键。<code>set -o emacs</code></p><p>如果想永久性更改编辑模式（Emacs / Vi），可以将命令写在<code>~/.inputrc</code>文件，这个文件是 Readline 的配置文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">set</span> editing-mode <span class="token function">vi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>本节介绍的快捷键都属于 Emacs 模式.</p><p>Bash 默认开启这个库，但是允许关闭。<code>--noediting</code>参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">bash</span> <span class="token parameter variable">--noediting</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="快捷键" tabindex="-1"><a class="header-anchor" href="#快捷键" aria-hidden="true">#</a> 快捷键</h3><p>Readline 提供快速移动光标的快捷键。</p><ul><li><code>Ctrl + a</code>：移到行首。</li><li><code>Ctrl + b</code>：向行首移动一个字符，与左箭头作用相同。</li><li><code>Ctrl + e</code>：移到行尾。</li><li><code>Ctrl + f</code>：向行尾移动一个字符，与右箭头作用相同。</li><li><code>Ctrl + l</code>快捷键可以清除屏幕，即将当前行移到屏幕的第一行</li></ul><h3 id="操作历史" tabindex="-1"><a class="header-anchor" href="#操作历史" aria-hidden="true">#</a> 操作历史</h3><p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入<code>~/.bash_history</code>文件。</p><p>环境变量<code>HISTFILE</code>总是指向这个文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token environment constant">$HISTFILE</span>
/Users/liushun/.zsh_history
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>!e</code>表示找出操作历史之中，最近的那一条以<code>e</code>开头的命令，然后加载到命令行，可以选择回车执行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> liushun@liushun  ~  <span class="token operator">!</span>e
 liushun@liushun  ~  <span class="token builtin class-name">echo</span> <span class="token environment constant">$HISTFILE</span>
/Users/liushun/.zsh_history
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>history 命令</strong></p><p><code>history</code>命令能显示操作历史，即<code>.bash_history</code>文件的内容。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token number">2481</span>  <span class="token function">expr</span> <span class="token number">3</span> + <span class="token number">2</span>
 <span class="token number">2482</span>  <span class="token function">expr</span> <span class="token variable">$foo</span> + <span class="token number">25</span>
 <span class="token number">2483</span>  <span class="token function">expr</span> <span class="token number">3.5</span> + <span class="token number">2</span>
 <span class="token number">2484</span>  <span class="token function">history</span>
 <span class="token number">2485</span>  llllll
 <span class="token number">2486</span>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>foo <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token variable">))</span></span>
 <span class="token number">2487</span>  <span class="token builtin class-name">echo</span> <span class="token environment constant">$HISTFILE</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想搜索某个以前执行的命令，可以配合<code>grep</code>命令搜索操作历史。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> ~/ <span class="token function">history</span> <span class="token operator">|</span> <span class="token function">grep</span> prin    
 <span class="token number">1114</span>  <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;chore: delete print&quot;</span>
 <span class="token number">2394</span>  <span class="token function">printenv</span> <span class="token environment constant">PATH</span>
 <span class="token number">2395</span>  <span class="token function">printenv</span> <span class="token environment constant">SHELL</span>
 <span class="token number">2493</span>  <span class="token function">printenv</span> HISTTIMEFORMAT
 <span class="token number">2500</span>  <span class="token function">printenv</span> HISTTIMEFORMAT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="目录堆栈" tabindex="-1"><a class="header-anchor" href="#目录堆栈" aria-hidden="true">#</a> 目录堆栈</h2><p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p><h3 id="cd" tabindex="-1"><a class="header-anchor" href="#cd" aria-hidden="true">#</a> cd -</h3><p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code>命令可以返回前一次的目录。</p><h3 id="pushd-popd" tabindex="-1"><a class="header-anchor" href="#pushd-popd" aria-hidden="true">#</a> pushd，popd</h3><p>如果希望记忆多重目录，可以使用<code>pushd</code>命令和<code>popd</code>命令。它们用来操作目录堆栈。</p><p><code>pushd</code>命令的用法类似<code>cd</code>命令，可以进入指定的目录。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ pushd dirname
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会进入目录<code>dirname</code>，并将该目录放入堆栈。</p><p>第一次使用<code>pushd</code>命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用<code>pushd</code>命令，都会将所要进入的目录，放在堆栈的顶部。</p><p><code>popd</code>命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录（即原来的第二条目录）。</p><p>这两个命令的参数如下。</p><p><strong>（1）-n 参数</strong></p><p><code>-n</code>的参数表示仅操作堆栈，不改变目录。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ popd -n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p><p><strong>（2）整数参数</strong></p><p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录（从0开始），作为操作对象。这时不会切换目录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 从栈顶算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="token function">pushd</span> +3
<span class="token comment"># 从栈底算起的3号目录（从0开始），移动到栈顶</span>
$ <span class="token function">pushd</span> <span class="token parameter variable">-3</span>
<span class="token comment"># 删除从栈顶算起的3号目录（从0开始）</span>
$ <span class="token function">popd</span> +3
<span class="token comment"># 删除从栈底算起的3号目录（从0开始）</span>
$ <span class="token function">popd</span> <span class="token parameter variable">-3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子的整数编号都是从0开始计算，<code>popd +0</code>是删除第一个目录，<code>popd +1</code>是删除第二个，<code>popd -0</code>是删除最后一个目录，，<code>popd -1</code>是删除倒数第二个。</p><p><strong>（3）目录参数</strong></p><p><code>pushd</code>可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ pushd dir
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>popd</code>没有这个参数。</p><h3 id="dirs-命令" tabindex="-1"><a class="header-anchor" href="#dirs-命令" aria-hidden="true">#</a> dirs 命令</h3><p><code>dirs</code>命令可以显示目录堆栈的内容，一般用来查看<code>pushd</code>和<code>popd</code>操作后的结果。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ dirs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它有以下参数。</p><ul><li><code>-c</code>：清空目录栈。</li><li><code>-l</code>：用户主目录不显示波浪号前缀，而打印完整的目录。</li><li><code>-p</code>：每行一个条目打印目录栈，默认是打印在一行。</li><li><code>-v</code>：每行一个条目，每个条目之前显示位置编号（从0开始）。</li><li><code>+N</code>：<code>N</code>为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li><li><code>-N</code>：<code>N</code>为整数，表示显示堆底算起的第 N 个目录，从零开始。</li></ul>`,459),c=[i];function d(o,p){return a(),n("div",null,c)}const r=s(l,[["render",d],["__file","base.html.vue"]]);export{r as default};
