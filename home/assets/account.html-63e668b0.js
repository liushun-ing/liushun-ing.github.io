import{_ as r,r as i,o as n,c,b as a,d as e,e as s,a as o}from"./app-d39e0209.js";const l="/home/assets/account-c5137750.png",d={},h=o('<h1 id="以太坊账户" tabindex="-1"><a class="header-anchor" href="#以太坊账户" aria-hidden="true">#</a> 以太坊账户</h1><p>一个以太坊帐户是一个具有以太币 (ETH) 余额的实体，可以在以太坊上发送交易。 帐户可以由用户控制，也可以作为智能合约部署。</p><h2 id="帐户类型" tabindex="-1"><a class="header-anchor" href="#帐户类型" aria-hidden="true">#</a> 帐户类型</h2><p>以太坊有两种帐户类型：</p><ul><li>外部所有的帐户 (EOA) – 由任何拥有私钥的人控制</li><li>合约帐户 – 部署到网络上的智能合约，由代码控制。</li></ul><p>这两种帐户类型都能：</p><ul><li>接收、持有和发送 ETH 和 token</li><li>与已部署的智能合约进行交互</li></ul><img src="'+l+'" alt="screenshot2024-07-19 16.02.24" style="zoom:50%;"><h2 id="主要区别" tabindex="-1"><a class="header-anchor" href="#主要区别" aria-hidden="true">#</a> 主要区别</h2><p><strong>外部持有</strong></p><ul><li>创建帐户是免费的</li><li>可以发起交易</li><li>外部所有的帐户之间只能进行以太币和代币交易</li><li>由一对加密密钥组成：控制帐户活动的公钥和私钥</li></ul><p><strong>合约</strong></p><ul><li>创建合约<strong>存在成本</strong>，因为需要使用网络存储空间</li><li>只能在收到交易时发送交易</li><li>从外部帐户向合约帐户发起的交易能触发可执行多种操作的代码，例如转移代币甚至创建新合约</li><li>合约帐户没有私钥。 相反，它们由智能合约代码逻辑控制</li></ul><h2 id="内容" tabindex="-1"><a class="header-anchor" href="#内容" aria-hidden="true">#</a> 内容</h2><p>以太坊帐户有四个字段：</p><ul><li><code>nonce</code> - 一个计数器，用来显示外部帐户发送的交易数量或合约帐户创建的合约数量。 每个帐户只能执行具有一个给定随机数的一笔交易，以防范重放攻击，重放攻击指多次广播和重复执行已签署的交易。</li><li><code>balance</code> – 这个地址拥有的 Wei 数量。 Wei 是以太币的计数单位，每个 ETH 有 1e+18 个 Wei。</li><li><code>codeHash</code> - 该哈希表示以太坊虚拟机 (EVM) 上的帐户<em>代码</em>。 合约帐户具有编程的代码片段，可以执行不同的操作。 如果帐户收到消息调用，则执行此 EVM 代码。 与其他帐户字段不同，不能更改。 所有代码片段都被保存在状态数据库的相应哈希下，供后续检索。 此哈希值称为 codeHash。 对于外部所有的帐户，codeHash 字段是空字符串的哈希。代码区即为智能合约代码本身。 在合约的生命周期中，该区域的内容是不可更改的 <strong>只读状态</strong>。 代码区存放于以太坊网络节点的硬盘中，当运行时被读入虚拟机执行。代码区的内容通过散列函数得出校验哈希值，该值即为代码区的哈希值。</li><li><code>storageRoot</code> – 有时被称为存储哈希。 Merkle Patricia trie 根节点的 256 位哈希已编码了帐户的存储内容（256 位整数值映射），并编码为 Trie，作为来自 256 的 Keccak 256 位哈希的映射位整数键，用于 RLP 编码的256位整数值。 此 Trie 对此帐户存储内容的哈希进行编码，默认情况下为空。存储区即为智能合约在运行中，产生的数据的存储地。 在合约的生命周期里，该区域的内容被合约代码不断写入、读取。 存储区存放于以太坊网络节点的硬盘上。 存储区的内容通过散列函数得出校验哈希值，该值即为存储区的哈希值。</li></ul><img src="https://ethereum.org/_next/image/?url=%2Fcontent%2Ftranslations%2Fzh%2Fdevelopers%2Fdocs%2Faccounts%2Faccounts.png&amp;w=1920&amp;q=75" style="zoom:33%;"><h2 id="外部持有的帐户和密钥对" tabindex="-1"><a class="header-anchor" href="#外部持有的帐户和密钥对" aria-hidden="true">#</a> 外部持有的帐户和密钥对</h2><p>帐户由公钥和私钥加密对组成。 它们有助于证明交易实际上是由发送者签名的，并防止伪造。 你的私钥是你用来签名交易的密钥，所以它保障你对与自己帐户相关的资金进行管理。 你从未真正持有加密货币，你持有私钥 – 资金总是在以太坊的账本上。</p><p>这将防止恶意参与者广播虚假交易，因为你总是可以验证交易的发送者。</p><h2 id="外部账户创建" tabindex="-1"><a class="header-anchor" href="#外部账户创建" aria-hidden="true">#</a> 外部账户创建</h2><p>想要创建一个帐户时，大多数库将生成一个随机的私钥。</p><p>私钥由 <strong>64 个十六进制字符</strong>组成，可以用密码加密保存。</p><p>例如：<code>fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036415f</code></p>',24),p={href:"https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm",target:"_blank",rel:"noopener noreferrer"},f=a("code",null,"0x",-1),u=o('<h2 id="合约帐户" tabindex="-1"><a class="header-anchor" href="#合约帐户" aria-hidden="true">#</a> 合约帐户</h2><p>合约帐户也有一个 42 个字符组成的十六进制地址：</p><p>例如：<code>0x06012c8cf97bead5deae237070f9587f8e7a266d</code></p><p>合约地址通常在将合约部署到以太坊区块链时给出。 地址产生自创建人的地址和从创建人地址发送的交易数量（“nonce”）。</p><blockquote><p>重要</p></blockquote><p>根据以太坊黄皮书，账户若是一个智能合约账户，则必定包含了 <strong>存储树</strong> （storageRoot）和 <strong>代码存储</strong> （codeHash）。</p><p>若我们继续放大观察存储树，即为上图最左边的树。存储树保存了智能合约的变量数据，它维持着256位的变量数据索引与RLP 算法编码过的256位数据本身。</p><p>为保证数据完整性，这些数据 <em>也被组织成一棵 MPT 树的形式</em> 。该MPT树的根节点哈希值称为 <strong>存储树</strong> 。</p><p>Note</p><p><strong>存储树</strong> 是账户状态的一个 <em>域</em> ，该值随着合约的存储区的增加、删除、改动而不断变更。</p><p><strong>代码存储</strong> 是只读的，它是合约账户的所执行的代码，它在合约第一次创建完毕后就不可以再变更。</p>',11);function g(_,m){const t=i("ExternalLinkIcon");return n(),c("div",null,[h,a("p",null,[e("使用"),a("a",p,[e("椭圆曲线加密法"),s(t)]),e("从私钥生成公钥。 通过获取公钥 Keccak-256 哈希的最后 20 个字节并校验码前面添加 "),f,e("，可以为帐户获取公共地址。")]),u])}const x=r(d,[["render",g],["__file","account.html.vue"]]);export{x as default};
