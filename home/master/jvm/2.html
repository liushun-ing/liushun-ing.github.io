<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.62">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/home/imgs/favicon.ico"><title>JVM构成 | 不愿飞的蜂鸟首页</title><meta name="description" content="Five的垃圾库">
    <link rel="preload" href="/home/assets/style-d11d67ee.css" as="style"><link rel="stylesheet" href="/home/assets/style-d11d67ee.css">
    <link rel="modulepreload" href="/home/assets/app-617a181d.js"><link rel="modulepreload" href="/home/assets/2.html-70d13604.js"><link rel="modulepreload" href="/home/assets/2.html-35ec231b.js"><link rel="prefetch" href="/home/assets/index.html-8dd1a890.js" as="script"><link rel="prefetch" href="/home/assets/index.html-81b2fcca.js" as="script"><link rel="prefetch" href="/home/assets/index.html-061f017f.js" as="script"><link rel="prefetch" href="/home/assets/index.html-25f3e375.js" as="script"><link rel="prefetch" href="/home/assets/1.html-b316c5ed.js" as="script"><link rel="prefetch" href="/home/assets/2.html-ac2ea519.js" as="script"><link rel="prefetch" href="/home/assets/3.html-a16fc765.js" as="script"><link rel="prefetch" href="/home/assets/4.html-798018cd.js" as="script"><link rel="prefetch" href="/home/assets/5.html-18ce25f4.js" as="script"><link rel="prefetch" href="/home/assets/6.html-f31143bd.js" as="script"><link rel="prefetch" href="/home/assets/index.html-d4d6df4d.js" as="script"><link rel="prefetch" href="/home/assets/index.html-b98c27b4.js" as="script"><link rel="prefetch" href="/home/assets/algorithms.html-f5b5ee0a.js" as="script"><link rel="prefetch" href="/home/assets/c__.html-05ab7a9e.js" as="script"><link rel="prefetch" href="/home/assets/graph.html-dab7b16e.js" as="script"><link rel="prefetch" href="/home/assets/leetcode.html-f105e9f1.js" as="script"><link rel="prefetch" href="/home/assets/other_tree.html-22fe33b0.js" as="script"><link rel="prefetch" href="/home/assets/sort_and_search.html-11f53bfb.js" as="script"><link rel="prefetch" href="/home/assets/string.html-e9db3916.js" as="script"><link rel="prefetch" href="/home/assets/tree.html-ec32110e.js" as="script"><link rel="prefetch" href="/home/assets/1.html-769a7684.js" as="script"><link rel="prefetch" href="/home/assets/2.html-594984b8.js" as="script"><link rel="prefetch" href="/home/assets/3.html-5ac058a8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-8a655167.js" as="script"><link rel="prefetch" href="/home/assets/1.html-99884eac.js" as="script"><link rel="prefetch" href="/home/assets/10.html-75dc6e9d.js" as="script"><link rel="prefetch" href="/home/assets/11.html-44ed8d03.js" as="script"><link rel="prefetch" href="/home/assets/12.html-1cafae42.js" as="script"><link rel="prefetch" href="/home/assets/13.html-cf9e5046.js" as="script"><link rel="prefetch" href="/home/assets/14.html-513b431e.js" as="script"><link rel="prefetch" href="/home/assets/2.html-094a87ee.js" as="script"><link rel="prefetch" href="/home/assets/3.html-4a8b2796.js" as="script"><link rel="prefetch" href="/home/assets/4.html-1f39f3b9.js" as="script"><link rel="prefetch" href="/home/assets/5.html-e78784fc.js" as="script"><link rel="prefetch" href="/home/assets/6.html-cc4acb22.js" as="script"><link rel="prefetch" href="/home/assets/7.html-ff096a2a.js" as="script"><link rel="prefetch" href="/home/assets/8.html-14b4319a.js" as="script"><link rel="prefetch" href="/home/assets/9.html-f1fd1f24.js" as="script"><link rel="prefetch" href="/home/assets/index.html-47fde470.js" as="script"><link rel="prefetch" href="/home/assets/index.html-994c7095.js" as="script"><link rel="prefetch" href="/home/assets/base_concept.html-8c9eb618.js" as="script"><link rel="prefetch" href="/home/assets/python_usage.html-6eb25c4d.js" as="script"><link rel="prefetch" href="/home/assets/pytorch_usage.html-12ebfb9e.js" as="script"><link rel="prefetch" href="/home/assets/index.html-1dd9832e.js" as="script"><link rel="prefetch" href="/home/assets/gas_fee.html-5bc12f1e.js" as="script"><link rel="prefetch" href="/home/assets/statedb_execute.html-4d958d64.js" as="script"><link rel="prefetch" href="/home/assets/23_Dec.html-b55b0d44.js" as="script"><link rel="prefetch" href="/home/assets/23_Nov.html-7f12af9c.js" as="script"><link rel="prefetch" href="/home/assets/24_Jan.html-aa29373f.js" as="script"><link rel="prefetch" href="/home/assets/index.html-cf670ace.js" as="script"><link rel="prefetch" href="/home/assets/index.html-e9115f16.js" as="script"><link rel="prefetch" href="/home/assets/compose.html-72dd1522.js" as="script"><link rel="prefetch" href="/home/assets/image_construct.html-803fa8bb.js" as="script"><link rel="prefetch" href="/home/assets/intro.html-c97d438d.js" as="script"><link rel="prefetch" href="/home/assets/framework.html-26732a5d.js" as="script"><link rel="prefetch" href="/home/assets/interview.html-c43e6b5a.js" as="script"><link rel="prefetch" href="/home/assets/javabase.html-4b7acc92.js" as="script"><link rel="prefetch" href="/home/assets/javacollection.html-7d0eec7c.js" as="script"><link rel="prefetch" href="/home/assets/javaio.html-2e0ce7a0.js" as="script"><link rel="prefetch" href="/home/assets/javajuc.html-e3adfcb3.js" as="script"><link rel="prefetch" href="/home/assets/project.html-ee5d4ecd.js" as="script"><link rel="prefetch" href="/home/assets/index.html-c00cd462.js" as="script"><link rel="prefetch" href="/home/assets/account.html-f2972d26.js" as="script"><link rel="prefetch" href="/home/assets/block.html-a9d64f7a.js" as="script"><link rel="prefetch" href="/home/assets/consensus.html-b378602e.js" as="script"><link rel="prefetch" href="/home/assets/contract.html-ebb9a32c.js" as="script"><link rel="prefetch" href="/home/assets/crypto_base.html-6226e31f.js" as="script"><link rel="prefetch" href="/home/assets/erc20.html-9175e857.js" as="script"><link rel="prefetch" href="/home/assets/ethereum_base.html-ed8afc4d.js" as="script"><link rel="prefetch" href="/home/assets/evm.html-c6aa4ef2.js" as="script"><link rel="prefetch" href="/home/assets/gas.html-7e483dbf.js" as="script"><link rel="prefetch" href="/home/assets/go_ethereum.html-7454bd3e.js" as="script"><link rel="prefetch" href="/home/assets/hd_wallet.html-3b70c8a3.js" as="script"><link rel="prefetch" href="/home/assets/jsonrpc.html-4b92012b.js" as="script"><link rel="prefetch" href="/home/assets/leveldb.html-f6dcddfb.js" as="script"><link rel="prefetch" href="/home/assets/mev.html-3b28f6dc.js" as="script"><link rel="prefetch" href="/home/assets/mpt.html-78685936.js" as="script"><link rel="prefetch" href="/home/assets/node_client.html-1945c0e1.js" as="script"><link rel="prefetch" href="/home/assets/rlp.html-c63951dd.js" as="script"><link rel="prefetch" href="/home/assets/statedb.html-57e0e0ee.js" as="script"><link rel="prefetch" href="/home/assets/transaction.html-ea80179c.js" as="script"><link rel="prefetch" href="/home/assets/index.html-737a4dbc.js" as="script"><link rel="prefetch" href="/home/assets/distributed.html-cb9755f7.js" as="script"><link rel="prefetch" href="/home/assets/gin.html-93f5f92b.js" as="script"><link rel="prefetch" href="/home/assets/gorm_1.html-c2cc8863.js" as="script"><link rel="prefetch" href="/home/assets/gorm_2.html-c9e371bb.js" as="script"><link rel="prefetch" href="/home/assets/goweb.html-dfefa78e.js" as="script"><link rel="prefetch" href="/home/assets/protobuf.html-46891574.js" as="script"><link rel="prefetch" href="/home/assets/rpc.html-2433bbc8.js" as="script"><link rel="prefetch" href="/home/assets/sse.html-86957496.js" as="script"><link rel="prefetch" href="/home/assets/test.html-0295cc69.js" as="script"><link rel="prefetch" href="/home/assets/websocket.html-2392370e.js" as="script"><link rel="prefetch" href="/home/assets/1.html-f201c773.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3732bf90.js" as="script"><link rel="prefetch" href="/home/assets/1.html-8f3c150c.js" as="script"><link rel="prefetch" href="/home/assets/3.html-5d7e2173.js" as="script"><link rel="prefetch" href="/home/assets/4.html-b019902a.js" as="script"><link rel="prefetch" href="/home/assets/index.html-dd915206.js" as="script"><link rel="prefetch" href="/home/assets/index.html-09a96e5d.js" as="script"><link rel="prefetch" href="/home/assets/section0.html-44da5c58.js" as="script"><link rel="prefetch" href="/home/assets/index.html-9e6553b4.js" as="script"><link rel="prefetch" href="/home/assets/mybatis.html-9fde4bbc.js" as="script"><link rel="prefetch" href="/home/assets/1.html-86ebf5bf.js" as="script"><link rel="prefetch" href="/home/assets/2.html-ef334cb2.js" as="script"><link rel="prefetch" href="/home/assets/index.html-beacf8a6.js" as="script"><link rel="prefetch" href="/home/assets/index.html-27666f68.js" as="script"><link rel="prefetch" href="/home/assets/dockerbase.html-359d1c8c.js" as="script"><link rel="prefetch" href="/home/assets/dockerutil.html-7ea89af6.js" as="script"><link rel="prefetch" href="/home/assets/k8sbase.html-dbb7e878.js" as="script"><link rel="prefetch" href="/home/assets/index.html-5b4a2fd2.js" as="script"><link rel="prefetch" href="/home/assets/alert.html-5d3a906c.js" as="script"><link rel="prefetch" href="/home/assets/clustering.html-1888741f.js" as="script"><link rel="prefetch" href="/home/assets/exporter.html-a7927412.js" as="script"><link rel="prefetch" href="/home/assets/intro.html-6a3e2ba8.js" as="script"><link rel="prefetch" href="/home/assets/promql.html-21c67535.js" as="script"><link rel="prefetch" href="/home/assets/servicediscovery.html-22fe93b7.js" as="script"><link rel="prefetch" href="/home/assets/index.html-5747b02b.js" as="script"><link rel="prefetch" href="/home/assets/base_usage.html-313edb82.js" as="script"><link rel="prefetch" href="/home/assets/1.html-84171baf.js" as="script"><link rel="prefetch" href="/home/assets/2.html-96474bc6.js" as="script"><link rel="prefetch" href="/home/assets/3.html-20b1a547.js" as="script"><link rel="prefetch" href="/home/assets/4.html-37db0907.js" as="script"><link rel="prefetch" href="/home/assets/index.html-9d407164.js" as="script"><link rel="prefetch" href="/home/assets/index.html-524f529c.js" as="script"><link rel="prefetch" href="/home/assets/jwt.html-c1c6066a.js" as="script"><link rel="prefetch" href="/home/assets/shiro.html-e4c32de8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-08bf43f7.js" as="script"><link rel="prefetch" href="/home/assets/nacos.html-ed2737e7.js" as="script"><link rel="prefetch" href="/home/assets/index.html-60425c3d.js" as="script"><link rel="prefetch" href="/home/assets/spring_annotation.html-3e4c4f76.js" as="script"><link rel="prefetch" href="/home/assets/springboot.html-dd3747fd.js" as="script"><link rel="prefetch" href="/home/assets/springboot_base.html-cd23c0a8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-1bcb2be9.js" as="script"><link rel="prefetch" href="/home/assets/docker_tutorial.html-4f5d0900.js" as="script"><link rel="prefetch" href="/home/assets/firewall_tutorial.html-a1c0f732.js" as="script"><link rel="prefetch" href="/home/assets/mysql_tutorial.html-4c6ba5d6.js" as="script"><link rel="prefetch" href="/home/assets/nginx_tutorial.html-93df5119.js" as="script"><link rel="prefetch" href="/home/assets/other_tutorial.html-c3d0505a.js" as="script"><link rel="prefetch" href="/home/assets/1.html-51f0ec55.js" as="script"><link rel="prefetch" href="/home/assets/2.html-a59bf622.js" as="script"><link rel="prefetch" href="/home/assets/index.html-b0e9f560.js" as="script"><link rel="prefetch" href="/home/assets/5.html-a4a0234f.js" as="script"><link rel="prefetch" href="/home/assets/6.html-d1f646bc.js" as="script"><link rel="prefetch" href="/home/assets/7.html-4bfc5de3.js" as="script"><link rel="prefetch" href="/home/assets/Mybatis.html-999b181b.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3e3eac32.js" as="script"><link rel="prefetch" href="/home/assets/Spring.html-ebdaae63.js" as="script"><link rel="prefetch" href="/home/assets/SpringBoot.html-c1676d63.js" as="script"><link rel="prefetch" href="/home/assets/SpringMVC.html-7bf971fc.js" as="script"><link rel="prefetch" href="/home/assets/1.html-095f3a2d.js" as="script"><link rel="prefetch" href="/home/assets/2.html-820329b9.js" as="script"><link rel="prefetch" href="/home/assets/3.html-65fa04a9.js" as="script"><link rel="prefetch" href="/home/assets/4.html-6cc0fdbb.js" as="script"><link rel="prefetch" href="/home/assets/5.html-4382da55.js" as="script"><link rel="prefetch" href="/home/assets/index.html-2c443520.js" as="script"><link rel="prefetch" href="/home/assets/index.html-dbf7dd00.js" as="script"><link rel="prefetch" href="/home/assets/java_usage.html-baf8cd68.js" as="script"><link rel="prefetch" href="/home/assets/python_usage.html-5785b28e.js" as="script"><link rel="prefetch" href="/home/assets/system_usage.html-e9649787.js" as="script"><link rel="prefetch" href="/home/assets/1.html-2d63875b.js" as="script"><link rel="prefetch" href="/home/assets/2.html-96ffe2d7.js" as="script"><link rel="prefetch" href="/home/assets/3.html-164f28d8.js" as="script"><link rel="prefetch" href="/home/assets/4.html-770067b7.js" as="script"><link rel="prefetch" href="/home/assets/5.html-94e4a58f.js" as="script"><link rel="prefetch" href="/home/assets/6.html-5fbe2511.js" as="script"><link rel="prefetch" href="/home/assets/7.html-6aaf4692.js" as="script"><link rel="prefetch" href="/home/assets/8.html-6c442319.js" as="script"><link rel="prefetch" href="/home/assets/9.html-1a1241a0.js" as="script"><link rel="prefetch" href="/home/assets/index.html-ca14f1ca.js" as="script"><link rel="prefetch" href="/home/assets/new.html-f39ecd3a.js" as="script"><link rel="prefetch" href="/home/assets/1.html-c051337a.js" as="script"><link rel="prefetch" href="/home/assets/2.html-c475ae33.js" as="script"><link rel="prefetch" href="/home/assets/index.html-7a9eb86e.js" as="script"><link rel="prefetch" href="/home/assets/1.html-e6ed9dbf.js" as="script"><link rel="prefetch" href="/home/assets/2.html-76ba2e41.js" as="script"><link rel="prefetch" href="/home/assets/index.html-202d5f4b.js" as="script"><link rel="prefetch" href="/home/assets/index.html-0a2a0106.js" as="script"><link rel="prefetch" href="/home/assets/less.html-26b18828.js" as="script"><link rel="prefetch" href="/home/assets/sass.html-e33a9ecf.js" as="script"><link rel="prefetch" href="/home/assets/1.html-f45e37f8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3b81aa58.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3505c412.js" as="script"><link rel="prefetch" href="/home/assets/uniCloud.html-d6f4a4e6.js" as="script"><link rel="prefetch" href="/home/assets/uniTips.html-c522b2d1.js" as="script"><link rel="prefetch" href="/home/assets/1.html-3be78b60.js" as="script"><link rel="prefetch" href="/home/assets/index.html-6602172a.js" as="script"><link rel="prefetch" href="/home/assets/index.html-dcc009ab.js" as="script"><link rel="prefetch" href="/home/assets/api_tutorial.html-201e8b68.js" as="script"><link rel="prefetch" href="/home/assets/base_tutorial.html-553e9cd8.js" as="script"><link rel="prefetch" href="/home/assets/pinia.html-93944f84.js" as="script"><link rel="prefetch" href="/home/assets/vue2.html-396e5caf.js" as="script"><link rel="prefetch" href="/home/assets/vue3_1.html-a3f127a4.js" as="script"><link rel="prefetch" href="/home/assets/vue3_2.html-52a41818.js" as="script"><link rel="prefetch" href="/home/assets/1.html-6b5b0d34.js" as="script"><link rel="prefetch" href="/home/assets/index.html-f9a24ca8.js" as="script"><link rel="prefetch" href="/home/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/home/assets/index.html-c154d73f.js" as="script"><link rel="prefetch" href="/home/assets/index.html-f02b8e42.js" as="script"><link rel="prefetch" href="/home/assets/index.html-84a82b25.js" as="script"><link rel="prefetch" href="/home/assets/index.html-5e5a0dfc.js" as="script"><link rel="prefetch" href="/home/assets/1.html-fa684d89.js" as="script"><link rel="prefetch" href="/home/assets/2.html-4c7fb277.js" as="script"><link rel="prefetch" href="/home/assets/3.html-fa8e2a3c.js" as="script"><link rel="prefetch" href="/home/assets/4.html-cd2a5e69.js" as="script"><link rel="prefetch" href="/home/assets/5.html-05a65952.js" as="script"><link rel="prefetch" href="/home/assets/6.html-3c60e9e8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3d55ff14.js" as="script"><link rel="prefetch" href="/home/assets/index.html-71094957.js" as="script"><link rel="prefetch" href="/home/assets/algorithms.html-f45c8f21.js" as="script"><link rel="prefetch" href="/home/assets/c__.html-b230baae.js" as="script"><link rel="prefetch" href="/home/assets/graph.html-5baefdb7.js" as="script"><link rel="prefetch" href="/home/assets/leetcode.html-c844fc5e.js" as="script"><link rel="prefetch" href="/home/assets/other_tree.html-75662db3.js" as="script"><link rel="prefetch" href="/home/assets/sort_and_search.html-808f5484.js" as="script"><link rel="prefetch" href="/home/assets/string.html-38be359e.js" as="script"><link rel="prefetch" href="/home/assets/tree.html-0aa82060.js" as="script"><link rel="prefetch" href="/home/assets/1.html-3de2d25e.js" as="script"><link rel="prefetch" href="/home/assets/2.html-cd79a788.js" as="script"><link rel="prefetch" href="/home/assets/3.html-c2c1aa9c.js" as="script"><link rel="prefetch" href="/home/assets/index.html-e79bb170.js" as="script"><link rel="prefetch" href="/home/assets/1.html-e47aac9e.js" as="script"><link rel="prefetch" href="/home/assets/10.html-b8b4945e.js" as="script"><link rel="prefetch" href="/home/assets/11.html-5fba22ed.js" as="script"><link rel="prefetch" href="/home/assets/12.html-59b3e608.js" as="script"><link rel="prefetch" href="/home/assets/13.html-8134c2cd.js" as="script"><link rel="prefetch" href="/home/assets/14.html-733fccd4.js" as="script"><link rel="prefetch" href="/home/assets/2.html-2b223d41.js" as="script"><link rel="prefetch" href="/home/assets/3.html-c3b8190a.js" as="script"><link rel="prefetch" href="/home/assets/4.html-ca0f31b1.js" as="script"><link rel="prefetch" href="/home/assets/5.html-c0f2d2d6.js" as="script"><link rel="prefetch" href="/home/assets/6.html-11e1a3a8.js" as="script"><link rel="prefetch" href="/home/assets/7.html-e550556e.js" as="script"><link rel="prefetch" href="/home/assets/8.html-42b7f4fe.js" as="script"><link rel="prefetch" href="/home/assets/9.html-eea9c7c6.js" as="script"><link rel="prefetch" href="/home/assets/index.html-9e2b3a94.js" as="script"><link rel="prefetch" href="/home/assets/index.html-73fa8bf8.js" as="script"><link rel="prefetch" href="/home/assets/base_concept.html-ce0e9270.js" as="script"><link rel="prefetch" href="/home/assets/python_usage.html-365551bc.js" as="script"><link rel="prefetch" href="/home/assets/pytorch_usage.html-450d3860.js" as="script"><link rel="prefetch" href="/home/assets/index.html-145ea489.js" as="script"><link rel="prefetch" href="/home/assets/gas_fee.html-117effe1.js" as="script"><link rel="prefetch" href="/home/assets/statedb_execute.html-d8a30ba6.js" as="script"><link rel="prefetch" href="/home/assets/23_Dec.html-51f8693f.js" as="script"><link rel="prefetch" href="/home/assets/23_Nov.html-b751e955.js" as="script"><link rel="prefetch" href="/home/assets/24_Jan.html-e5858e58.js" as="script"><link rel="prefetch" href="/home/assets/index.html-519e51d1.js" as="script"><link rel="prefetch" href="/home/assets/index.html-33d75012.js" as="script"><link rel="prefetch" href="/home/assets/compose.html-11d8f5f0.js" as="script"><link rel="prefetch" href="/home/assets/image_construct.html-0419a0d7.js" as="script"><link rel="prefetch" href="/home/assets/intro.html-4fcc0393.js" as="script"><link rel="prefetch" href="/home/assets/framework.html-3233c122.js" as="script"><link rel="prefetch" href="/home/assets/interview.html-e5c7f6f2.js" as="script"><link rel="prefetch" href="/home/assets/javabase.html-2302c408.js" as="script"><link rel="prefetch" href="/home/assets/javacollection.html-ecc56d46.js" as="script"><link rel="prefetch" href="/home/assets/javaio.html-372bbe3d.js" as="script"><link rel="prefetch" href="/home/assets/javajuc.html-9116ddbd.js" as="script"><link rel="prefetch" href="/home/assets/project.html-e7e9576f.js" as="script"><link rel="prefetch" href="/home/assets/index.html-5443861d.js" as="script"><link rel="prefetch" href="/home/assets/account.html-6e71c80f.js" as="script"><link rel="prefetch" href="/home/assets/block.html-4c677cf5.js" as="script"><link rel="prefetch" href="/home/assets/consensus.html-f84b9497.js" as="script"><link rel="prefetch" href="/home/assets/contract.html-97678f2c.js" as="script"><link rel="prefetch" href="/home/assets/crypto_base.html-42510f18.js" as="script"><link rel="prefetch" href="/home/assets/erc20.html-e64147ae.js" as="script"><link rel="prefetch" href="/home/assets/ethereum_base.html-88ede3b5.js" as="script"><link rel="prefetch" href="/home/assets/evm.html-42c0377e.js" as="script"><link rel="prefetch" href="/home/assets/gas.html-29908b18.js" as="script"><link rel="prefetch" href="/home/assets/go_ethereum.html-75b25941.js" as="script"><link rel="prefetch" href="/home/assets/hd_wallet.html-5269ade8.js" as="script"><link rel="prefetch" href="/home/assets/jsonrpc.html-c46b5c18.js" as="script"><link rel="prefetch" href="/home/assets/leveldb.html-0fea79a4.js" as="script"><link rel="prefetch" href="/home/assets/mev.html-6a329ebd.js" as="script"><link rel="prefetch" href="/home/assets/mpt.html-0f80b014.js" as="script"><link rel="prefetch" href="/home/assets/node_client.html-305b2437.js" as="script"><link rel="prefetch" href="/home/assets/rlp.html-7f4f2005.js" as="script"><link rel="prefetch" href="/home/assets/statedb.html-f7447391.js" as="script"><link rel="prefetch" href="/home/assets/transaction.html-963f0604.js" as="script"><link rel="prefetch" href="/home/assets/index.html-888d5a06.js" as="script"><link rel="prefetch" href="/home/assets/distributed.html-c35815b0.js" as="script"><link rel="prefetch" href="/home/assets/gin.html-c7890715.js" as="script"><link rel="prefetch" href="/home/assets/gorm_1.html-2802bce4.js" as="script"><link rel="prefetch" href="/home/assets/gorm_2.html-8887ed11.js" as="script"><link rel="prefetch" href="/home/assets/goweb.html-3aa9b211.js" as="script"><link rel="prefetch" href="/home/assets/protobuf.html-b67190ba.js" as="script"><link rel="prefetch" href="/home/assets/rpc.html-633f4ba5.js" as="script"><link rel="prefetch" href="/home/assets/sse.html-70cfa8b2.js" as="script"><link rel="prefetch" href="/home/assets/test.html-b6a861eb.js" as="script"><link rel="prefetch" href="/home/assets/websocket.html-febfd286.js" as="script"><link rel="prefetch" href="/home/assets/1.html-8624ea2a.js" as="script"><link rel="prefetch" href="/home/assets/index.html-f5574174.js" as="script"><link rel="prefetch" href="/home/assets/1.html-70e2cb8e.js" as="script"><link rel="prefetch" href="/home/assets/3.html-ca21ce22.js" as="script"><link rel="prefetch" href="/home/assets/4.html-0920a403.js" as="script"><link rel="prefetch" href="/home/assets/index.html-24fa856e.js" as="script"><link rel="prefetch" href="/home/assets/index.html-922abfbc.js" as="script"><link rel="prefetch" href="/home/assets/section0.html-37daac87.js" as="script"><link rel="prefetch" href="/home/assets/index.html-8658ecb6.js" as="script"><link rel="prefetch" href="/home/assets/mybatis.html-4f45e41f.js" as="script"><link rel="prefetch" href="/home/assets/1.html-53c4ae03.js" as="script"><link rel="prefetch" href="/home/assets/2.html-617ea0da.js" as="script"><link rel="prefetch" href="/home/assets/index.html-4856be11.js" as="script"><link rel="prefetch" href="/home/assets/index.html-80693377.js" as="script"><link rel="prefetch" href="/home/assets/dockerbase.html-5e1a5b64.js" as="script"><link rel="prefetch" href="/home/assets/dockerutil.html-c5940d1a.js" as="script"><link rel="prefetch" href="/home/assets/k8sbase.html-cdbeb65b.js" as="script"><link rel="prefetch" href="/home/assets/index.html-95f3fee7.js" as="script"><link rel="prefetch" href="/home/assets/alert.html-8739d988.js" as="script"><link rel="prefetch" href="/home/assets/clustering.html-4f373be9.js" as="script"><link rel="prefetch" href="/home/assets/exporter.html-d9349f3f.js" as="script"><link rel="prefetch" href="/home/assets/intro.html-f50675b1.js" as="script"><link rel="prefetch" href="/home/assets/promql.html-7da95c46.js" as="script"><link rel="prefetch" href="/home/assets/servicediscovery.html-7d36a8a5.js" as="script"><link rel="prefetch" href="/home/assets/index.html-2678f481.js" as="script"><link rel="prefetch" href="/home/assets/base_usage.html-47832097.js" as="script"><link rel="prefetch" href="/home/assets/1.html-4978ddcb.js" as="script"><link rel="prefetch" href="/home/assets/2.html-237b1ad9.js" as="script"><link rel="prefetch" href="/home/assets/3.html-34365c7c.js" as="script"><link rel="prefetch" href="/home/assets/4.html-4414f033.js" as="script"><link rel="prefetch" href="/home/assets/index.html-2ded8c26.js" as="script"><link rel="prefetch" href="/home/assets/index.html-ed6e0263.js" as="script"><link rel="prefetch" href="/home/assets/jwt.html-503d08b5.js" as="script"><link rel="prefetch" href="/home/assets/shiro.html-a19404c3.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3704a120.js" as="script"><link rel="prefetch" href="/home/assets/nacos.html-7568cb59.js" as="script"><link rel="prefetch" href="/home/assets/index.html-b9498e3a.js" as="script"><link rel="prefetch" href="/home/assets/spring_annotation.html-3dee60ca.js" as="script"><link rel="prefetch" href="/home/assets/springboot.html-6c18e6a0.js" as="script"><link rel="prefetch" href="/home/assets/springboot_base.html-7ae86f70.js" as="script"><link rel="prefetch" href="/home/assets/index.html-7ef5651c.js" as="script"><link rel="prefetch" href="/home/assets/docker_tutorial.html-1a1d2303.js" as="script"><link rel="prefetch" href="/home/assets/firewall_tutorial.html-dd7a292f.js" as="script"><link rel="prefetch" href="/home/assets/mysql_tutorial.html-27b9f1d4.js" as="script"><link rel="prefetch" href="/home/assets/nginx_tutorial.html-ee73dc02.js" as="script"><link rel="prefetch" href="/home/assets/other_tutorial.html-0d707e61.js" as="script"><link rel="prefetch" href="/home/assets/1.html-59c8c680.js" as="script"><link rel="prefetch" href="/home/assets/2.html-64fff0c1.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3471ec41.js" as="script"><link rel="prefetch" href="/home/assets/5.html-b06a4ff8.js" as="script"><link rel="prefetch" href="/home/assets/6.html-436de607.js" as="script"><link rel="prefetch" href="/home/assets/7.html-10657168.js" as="script"><link rel="prefetch" href="/home/assets/Mybatis.html-587da610.js" as="script"><link rel="prefetch" href="/home/assets/index.html-7eb73fbe.js" as="script"><link rel="prefetch" href="/home/assets/Spring.html-6b894bc7.js" as="script"><link rel="prefetch" href="/home/assets/SpringBoot.html-310141ce.js" as="script"><link rel="prefetch" href="/home/assets/SpringMVC.html-387be687.js" as="script"><link rel="prefetch" href="/home/assets/1.html-b4a58503.js" as="script"><link rel="prefetch" href="/home/assets/2.html-e819782d.js" as="script"><link rel="prefetch" href="/home/assets/3.html-1d9b94ce.js" as="script"><link rel="prefetch" href="/home/assets/4.html-64dfcee6.js" as="script"><link rel="prefetch" href="/home/assets/5.html-8ac0cb75.js" as="script"><link rel="prefetch" href="/home/assets/index.html-ac3b2cea.js" as="script"><link rel="prefetch" href="/home/assets/index.html-8ccc69ae.js" as="script"><link rel="prefetch" href="/home/assets/java_usage.html-071ff5dd.js" as="script"><link rel="prefetch" href="/home/assets/python_usage.html-97562c77.js" as="script"><link rel="prefetch" href="/home/assets/system_usage.html-61f14901.js" as="script"><link rel="prefetch" href="/home/assets/1.html-06fad7cd.js" as="script"><link rel="prefetch" href="/home/assets/2.html-acbb3df9.js" as="script"><link rel="prefetch" href="/home/assets/3.html-8f24ecf5.js" as="script"><link rel="prefetch" href="/home/assets/4.html-12754ed7.js" as="script"><link rel="prefetch" href="/home/assets/5.html-9c860f5b.js" as="script"><link rel="prefetch" href="/home/assets/6.html-beab5d36.js" as="script"><link rel="prefetch" href="/home/assets/7.html-a73bc500.js" as="script"><link rel="prefetch" href="/home/assets/8.html-57b81f06.js" as="script"><link rel="prefetch" href="/home/assets/9.html-7f3f67d9.js" as="script"><link rel="prefetch" href="/home/assets/index.html-e5b946af.js" as="script"><link rel="prefetch" href="/home/assets/new.html-70f606fb.js" as="script"><link rel="prefetch" href="/home/assets/1.html-a7c5c502.js" as="script"><link rel="prefetch" href="/home/assets/2.html-41a5b7a8.js" as="script"><link rel="prefetch" href="/home/assets/index.html-a8dd429d.js" as="script"><link rel="prefetch" href="/home/assets/1.html-3b6189ea.js" as="script"><link rel="prefetch" href="/home/assets/2.html-a46ffe0b.js" as="script"><link rel="prefetch" href="/home/assets/index.html-3deacb43.js" as="script"><link rel="prefetch" href="/home/assets/index.html-c51177ec.js" as="script"><link rel="prefetch" href="/home/assets/less.html-1949c741.js" as="script"><link rel="prefetch" href="/home/assets/sass.html-42c335d3.js" as="script"><link rel="prefetch" href="/home/assets/1.html-d9b44cd6.js" as="script"><link rel="prefetch" href="/home/assets/index.html-aaeb6031.js" as="script"><link rel="prefetch" href="/home/assets/index.html-49d523ba.js" as="script"><link rel="prefetch" href="/home/assets/uniCloud.html-c0198ad0.js" as="script"><link rel="prefetch" href="/home/assets/uniTips.html-e426c3d1.js" as="script"><link rel="prefetch" href="/home/assets/1.html-c8205f27.js" as="script"><link rel="prefetch" href="/home/assets/index.html-53d2c33f.js" as="script"><link rel="prefetch" href="/home/assets/index.html-a71b02a4.js" as="script"><link rel="prefetch" href="/home/assets/api_tutorial.html-1960edf0.js" as="script"><link rel="prefetch" href="/home/assets/base_tutorial.html-594cbfdd.js" as="script"><link rel="prefetch" href="/home/assets/pinia.html-2a0f0f5d.js" as="script"><link rel="prefetch" href="/home/assets/vue2.html-4b33a431.js" as="script"><link rel="prefetch" href="/home/assets/vue3_1.html-2e625c81.js" as="script"><link rel="prefetch" href="/home/assets/vue3_2.html-229c2d55.js" as="script"><link rel="prefetch" href="/home/assets/1.html-362c7b7e.js" as="script"><link rel="prefetch" href="/home/assets/index.html-c7a88265.js" as="script"><link rel="prefetch" href="/home/assets/404.html-36680874.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/home/" class=""><!----><span class="site-name">不愿飞的蜂鸟首页</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five研究生"><span class="title">Five研究生</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five研究生"><span class="title">Five研究生</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Block Chain Internship</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/ethereum/" class="" aria-label="ethereum"><!--[--><!--]--> ethereum <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/blockchaindevelopment/" class="" aria-label="block chain developement"><!--[--><!--]--> block chain developement <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/docker/" class="" aria-label="docker"><!--[--><!--]--> docker <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/golang/" class="" aria-label="golang"><!--[--><!--]--> golang <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/prometheus/" class="" aria-label="prometheus"><!--[--><!--]--> prometheus <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Deep Learning</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/ubuntu/" class="" aria-label="Ubuntu"><!--[--><!--]--> Ubuntu <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/GNN/" class="" aria-label="GNN"><!--[--><!--]--> GNN <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java Engineering</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/jvm/" class="router-link-active" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/redis/" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/juc/" class="" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/netty/" class="" aria-label="Netty"><!--[--><!--]--> Netty <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/security/" class="" aria-label="Security"><!--[--><!--]--> Security <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/service/" class="" aria-label="Service"><!--[--><!--]--> Service <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/mybatis/" class="" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five本科技术"><span class="title">Five本科技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five本科技术"><span class="title">Five本科技术</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>foreground</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/js/" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/typescript/" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/html_css/" class="" aria-label="HTML_CSS"><!--[--><!--]--> HTML_CSS <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/less_sass/" class="" aria-label="Less_Sass"><!--[--><!--]--> Less_Sass <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/react/" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/vite/" class="" aria-label="Vite"><!--[--><!--]--> Vite <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/webpack/" class="" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>background</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/java/" class="" aria-label="JAVA"><!--[--><!--]--> JAVA <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/node/" class="" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>app.mp</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/miniProgram/" class="" aria-label="MiniProgram"><!--[--><!--]--> MiniProgram <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/uni-app/" class="" aria-label="uni-app"><!--[--><!--]--> uni-app <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>server</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/centos/" class="" aria-label="Centos"><!--[--><!--]--> Centos <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five本科课程"><span class="title">Five本科课程</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five本科课程"><span class="title">Five本科课程</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/home/course/operating_system/" class="" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/home/course/computer_network/" class="" aria-label="计算机网络技术"><!--[--><!--]--> 计算机网络技术 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/home/course/datastructure_and_algorithm/" class="" aria-label="数据结构和算法"><!--[--><!--]--> 数据结构和算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/liushun-ing" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five研究生"><span class="title">Five研究生</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five研究生"><span class="title">Five研究生</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Block Chain Internship</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/ethereum/" class="" aria-label="ethereum"><!--[--><!--]--> ethereum <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/blockchaindevelopment/" class="" aria-label="block chain developement"><!--[--><!--]--> block chain developement <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/docker/" class="" aria-label="docker"><!--[--><!--]--> docker <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/golang/" class="" aria-label="golang"><!--[--><!--]--> golang <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/prometheus/" class="" aria-label="prometheus"><!--[--><!--]--> prometheus <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Deep Learning</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/ubuntu/" class="" aria-label="Ubuntu"><!--[--><!--]--> Ubuntu <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/GNN/" class="" aria-label="GNN"><!--[--><!--]--> GNN <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/python/" class="" aria-label="Python"><!--[--><!--]--> Python <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>Java Engineering</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/master/spring/" class="" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/jvm/" class="router-link-active" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/redis/" class="" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/juc/" class="" aria-label="JUC"><!--[--><!--]--> JUC <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/netty/" class="" aria-label="Netty"><!--[--><!--]--> Netty <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/security/" class="" aria-label="Security"><!--[--><!--]--> Security <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/service/" class="" aria-label="Service"><!--[--><!--]--> Service <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/master/mybatis/" class="" aria-label="MyBatis"><!--[--><!--]--> MyBatis <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five本科技术"><span class="title">Five本科技术</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five本科技术"><span class="title">Five本科技术</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>foreground</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/js/" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/typescript/" class="" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/html_css/" class="" aria-label="HTML_CSS"><!--[--><!--]--> HTML_CSS <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/less_sass/" class="" aria-label="Less_Sass"><!--[--><!--]--> Less_Sass <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/react/" class="" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/vite/" class="" aria-label="Vite"><!--[--><!--]--> Vite <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/webpack/" class="" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>background</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/java/" class="" aria-label="JAVA"><!--[--><!--]--> JAVA <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/node/" class="" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>app.mp</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/miniProgram/" class="" aria-label="MiniProgram"><!--[--><!--]--> MiniProgram <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/home/tech/uni-app/" class="" aria-label="uni-app"><!--[--><!--]--> uni-app <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>server</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/home/tech/centos/" class="" aria-label="Centos"><!--[--><!--]--> Centos <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Five本科课程"><span class="title">Five本科课程</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Five本科课程"><span class="title">Five本科课程</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/home/course/operating_system/" class="" aria-label="操作系统"><!--[--><!--]--> 操作系统 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/home/course/computer_network/" class="" aria-label="计算机网络技术"><!--[--><!--]--> 计算机网络技术 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/home/course/datastructure_and_algorithm/" class="" aria-label="数据结构和算法"><!--[--><!--]--> 数据结构和算法 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/liushun-ing" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">JVM <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/home/master/jvm/" class="router-link-active sidebar-item" aria-label="Navigation"><!--[--><!--]--> Navigation <!--[--><!--]--></a><!----></li><li><a href="/home/master/jvm/1.html" class="sidebar-item" aria-label="JVM与Java体系结构"><!--[--><!--]--> JVM与Java体系结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JVM构成"><!--[--><!--]--> JVM构成 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/home/master/jvm/2.html#一、类加载子系统" class="router-link-active router-link-exact-active sidebar-item" aria-label="一、类加载子系统"><!--[--><!--]--> 一、类加载子系统 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/home/master/jvm/2.html#类加载过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="类加载过程"><!--[--><!--]--> 类加载过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#类加载器的分类" class="router-link-active router-link-exact-active sidebar-item" aria-label="类加载器的分类"><!--[--><!--]--> 类加载器的分类 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#虚拟机自带的加载器" class="router-link-active router-link-exact-active sidebar-item" aria-label="虚拟机自带的加载器"><!--[--><!--]--> 虚拟机自带的加载器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#双亲委派机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="双亲委派机制"><!--[--><!--]--> 双亲委派机制 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#其它" class="router-link-active router-link-exact-active sidebar-item" aria-label="其它"><!--[--><!--]--> 其它 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/home/master/jvm/2.html#二、运行时数据区" class="router-link-active router-link-exact-active sidebar-item" aria-label="二、运行时数据区"><!--[--><!--]--> 二、运行时数据区 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/home/master/jvm/2.html#线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="线程"><!--[--><!--]--> 线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#_1程序计数器" class="router-link-active router-link-exact-active sidebar-item" aria-label="1程序计数器"><!--[--><!--]--> 1程序计数器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#_2虚拟机栈" class="router-link-active router-link-exact-active sidebar-item" aria-label="2虚拟机栈"><!--[--><!--]--> 2虚拟机栈 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#_3本地方法栈" class="router-link-active router-link-exact-active sidebar-item" aria-label="3本地方法栈"><!--[--><!--]--> 3本地方法栈 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#_4堆" class="router-link-active router-link-exact-active sidebar-item" aria-label="4堆"><!--[--><!--]--> 4堆 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#_5方法区" class="router-link-active router-link-exact-active sidebar-item" aria-label="5方法区"><!--[--><!--]--> 5方法区 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#对象实例化内存布局与访问定位" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象实例化内存布局与访问定位"><!--[--><!--]--> 对象实例化内存布局与访问定位 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#直接内存direct-memory" class="router-link-active router-link-exact-active sidebar-item" aria-label="直接内存Direct Memory"><!--[--><!--]--> 直接内存Direct Memory <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/home/master/jvm/2.html#三、执行引擎" class="router-link-active router-link-exact-active sidebar-item" aria-label="三、执行引擎"><!--[--><!--]--> 三、执行引擎 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/home/master/jvm/2.html#执行引擎概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="执行引擎概述"><!--[--><!--]--> 执行引擎概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#java代码编译和执行过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="Java代码编译和执行过程"><!--[--><!--]--> Java代码编译和执行过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#机器码、指令、汇编语言" class="router-link-active router-link-exact-active sidebar-item" aria-label="机器码、指令、汇编语言"><!--[--><!--]--> 机器码、指令、汇编语言 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#解释器" class="router-link-active router-link-exact-active sidebar-item" aria-label="解释器"><!--[--><!--]--> 解释器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#jit编译器-1" class="router-link-active router-link-exact-active sidebar-item" aria-label="JIT编译器"><!--[--><!--]--> JIT编译器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/home/master/jvm/2.html#aot编译器" class="router-link-active router-link-exact-active sidebar-item" aria-label="AOT编译器"><!--[--><!--]--> AOT编译器 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/home/master/jvm/3.html" class="sidebar-item" aria-label="StringTable"><!--[--><!--]--> StringTable <!--[--><!--]--></a><!----></li><li><a href="/home/master/jvm/4.html" class="sidebar-item" aria-label="JVM垃圾回收"><!--[--><!--]--> JVM垃圾回收 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="jvm构成" tabindex="-1"><a class="header-anchor" href="#jvm构成" aria-hidden="true">#</a> JVM构成</h1><h2 id="一、类加载子系统" tabindex="-1"><a class="header-anchor" href="#一、类加载子系统" aria-hidden="true">#</a> 一、类加载子系统</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><img src="/home/assets/image-20200705081813409-17069335962331-977f5ad5.png" alt="image-20200705081813409" style="zoom:67%;"><ul><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</li><li>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ul><img src="/home/assets/image-20200705081913538-17069336040613-8c9ac2d7.png" alt="image-20200705081913538" style="zoom:67%;"><h3 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程" aria-hidden="true">#</a> 类加载过程</h3><img src="/home/assets/image-20200705082601441-17069336093915-0dc53a16.png" alt="image-20200705082601441" style="zoom:67%;"><h4 id="加载阶段" tabindex="-1"><a class="header-anchor" href="#加载阶段" aria-hidden="true">#</a> 加载阶段</h4><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h4 id="加载class文件的方式" tabindex="-1"><a class="header-anchor" href="#加载class文件的方式" aria-hidden="true">#</a> 加载class文件的方式</h4><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h4 id="链接阶段" tabindex="-1"><a class="header-anchor" href="#链接阶段" aria-hidden="true">#</a> 链接阶段</h4><h5 id="验证-verify" tabindex="-1"><a class="header-anchor" href="#验证-verify" aria-hidden="true">#</a> 验证 Verify</h5><blockquote><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p></blockquote><p>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p><h5 id="准备-prepare" tabindex="-1"><a class="header-anchor" href="#准备-prepare" aria-hidden="true">#</a> 准备 Prepare</h5><blockquote><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p></blockquote><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h5 id="解析-resolve" tabindex="-1"><a class="header-anchor" href="#解析-resolve" aria-hidden="true">#</a> 解析 Resolve</h5><blockquote><p>将常量池内的符号引用转换为直接引用的过程。</p></blockquote><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h4 id="初始化阶段" tabindex="-1"><a class="header-anchor" href="#初始化阶段" aria-hidden="true">#</a> 初始化阶段</h4><blockquote><p>初始化阶段就是执行类构造器法（）的过程。</p></blockquote><p>此方法不需定义，是javac编译器自动收集类中的<strong>所有类变量的赋值动作和静态代码块中的语句合并</strong>而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p>（）不同于类的构造器。（关联：构造器是虚拟机视角下的（））若该类具有父类，JVM会保证子类的（）执行前，父类的（）已经执行完毕。</p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><h3 id="类加载器的分类" tabindex="-1"><a class="header-anchor" href="#类加载器的分类" aria-hidden="true">#</a> 类加载器的分类</h3><p>JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><img src="/home/assets/image-20200705094149223-170688735241112-2f24eb61.png" alt="image-20200705094149223" style="zoom:50%;"><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系。</p><p>我们通过一个类，获取它不同的加载器</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取系统类加载器</span>
        <span class="token class-name">ClassLoader</span> systemClassLoader <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取其上层的：扩展类加载器</span>
        <span class="token class-name">ClassLoader</span> extClassLoader <span class="token operator">=</span> systemClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>extClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 试图获取 根加载器</span>
        <span class="token class-name">ClassLoader</span> bootstrapClassLoader <span class="token operator">=</span> extClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bootstrapClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取自定义加载器</span>
        <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> <span class="token class-name">ClassLoaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 获取String类型的加载器</span>
        <span class="token class-name">ClassLoader</span> classLoader1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>
<span class="token comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span>
<span class="token comment">//null</span>
<span class="token comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>
<span class="token comment">//null </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到的结果，从结果可以看出根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。</p><h3 id="虚拟机自带的加载器" tabindex="-1"><a class="header-anchor" href="#虚拟机自带的加载器" aria-hidden="true">#</a> 虚拟机自带的加载器</h3><h4 id="启动类加载器-引导类加载器-bootstrap-classloader" tabindex="-1"><a class="header-anchor" href="#启动类加载器-引导类加载器-bootstrap-classloader" aria-hidden="true">#</a> 启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h4 id="扩展类加载器-extension-classloader" tabindex="-1"><a class="header-anchor" href="#扩展类加载器-extension-classloader" aria-hidden="true">#</a> 扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h4 id="应用程序类加载器-系统类加载器-appclassloader" tabindex="-1"><a class="header-anchor" href="#应用程序类加载器-系统类加载器-appclassloader" aria-hidden="true">#</a> 应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h4 id="用户自定义类加载器" tabindex="-1"><a class="header-anchor" href="#用户自定义类加载器" aria-hidden="true">#</a> 用户自定义类加载器</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h4 id="classload" tabindex="-1"><a class="header-anchor" href="#classload" aria-hidden="true">#</a> ClassLoad</h4><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p>获取ClassLoader的途径</p><ul><li>获取当前ClassLoader：clazz.getClassLoader()</li><li>获取当前线程上下文的ClassLoader：Thread.currentThread().getContextClassLoader()</li><li>获取系统的ClassLoader：ClassLoader.getSystemClassLoader()</li><li>获取调用者的ClassLoader：DriverManager.getCallerClassLoader()</li></ul><h3 id="双亲委派机制" tabindex="-1"><a class="header-anchor" href="#双亲委派机制" aria-hidden="true">#</a> 双亲委派机制</h3><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><img src="/home/assets/image-20200705105151258-0656558-bd07694b.png" alt="image-20200705105151258" style="zoom:67%;"><h4 id="沙箱安全机制" tabindex="-1"><a class="header-anchor" href="#沙箱安全机制" aria-hidden="true">#</a> 沙箱安全机制</h4><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。<strong>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</strong></p><h4 id="双亲委派机制的优势" tabindex="-1"><a class="header-anchor" href="#双亲委派机制的优势" aria-hidden="true">#</a> 双亲委派机制的优势</h4><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改 <ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它" aria-hidden="true">#</a> 其它</h3><h4 id="如何判断两个class对象是否相同" tabindex="-1"><a class="header-anchor" href="#如何判断两个class对象是否相同" aria-hidden="true">#</a> 如何判断两个class对象是否相同</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h4 id="类的主动使用和被动使用" tabindex="-1"><a class="header-anchor" href="#类的主动使用和被动使用" aria-hidden="true">#</a> 类的主动使用和被动使用</h4><p>Java程序对类的使用方式分为：主动使用和被动使用。 主动使用，又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法I</li><li>反射（比如：Class.forName（&quot;com.atguigu.Test&quot;））</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p><h2 id="二、运行时数据区" tabindex="-1"><a class="header-anchor" href="#二、运行时数据区" aria-hidden="true">#</a> 二、运行时数据区</h2><img src="/home/assets/image-20200705112416101-17069337449828-65a365ba.png" alt="image-20200705112416101" style="zoom:50%;"><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>第一二层的为单独线程私有的，第三层为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><h3 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h3><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h4 id="jvm系统线程" tabindex="-1"><a class="header-anchor" href="#jvm系统线程" aria-hidden="true">#</a> JVM系统线程</h4><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括&quot;stop-the-world&quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><h3 id="_1程序计数器" tabindex="-1"><a class="header-anchor" href="#_1程序计数器" aria-hidden="true">#</a> 1程序计数器</h3><h4 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h4><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><img src="/home/assets/image-20200705155551919-170693402560311-98f5334f.png" alt="image-20200705155551919" style="zoom:67%;"><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。</p><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h4><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><img src="/home/assets/image-20200705155728557-a3a9fec9.png" alt="image-20200705155728557" style="zoom:67%;"><h4 id="cpu时间片" tabindex="-1"><a class="header-anchor" href="#cpu时间片" aria-hidden="true">#</a> CPU时间片</h4><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><h3 id="_2虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_2虚拟机栈" aria-hidden="true">#</a> 2虚拟机栈</h3><h4 id="虚拟机栈概述" tabindex="-1"><a class="header-anchor" href="#虚拟机栈概述" aria-hidden="true">#</a> 虚拟机栈概述</h4><p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java战（stack）？为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><h5 id="java虚拟机栈是什么" tabindex="-1"><a class="header-anchor" href="#java虚拟机栈是什么" aria-hidden="true">#</a> Java虚拟机栈是什么</h5><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><blockquote><p>是线程私有的</p></blockquote><h5 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h5><p>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</p><h5 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1" aria-hidden="true">#</a> 作用</h5><p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><blockquote><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p></blockquote><h5 id="栈的特点" tabindex="-1"><a class="header-anchor" href="#栈的特点" aria-hidden="true">#</a> 栈的特点</h5><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><img src="/home/assets/image-20200705165025382-170693432986717-81ba5c60.png" alt="image-20200705165025382" style="zoom:67%;"><h5 id="栈异常" tabindex="-1"><a class="header-anchor" href="#栈异常" aria-hidden="true">#</a> 栈异常</h5><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常。</p><h5 id="设置栈内存大小" tabindex="-1"><a class="header-anchor" href="#设置栈内存大小" aria-hidden="true">#</a> 设置栈内存大小</h5><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-Xss1m
-Xss1k
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="栈的存储单位" tabindex="-1"><a class="header-anchor" href="#栈的存储单位" aria-hidden="true">#</a> 栈的存储单位</h5><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><blockquote><p>OOP的基本概念：类和对象</p><p>类中基本结构：field（属性、字段、域）、method</p></blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><h6 id="栈运行原理" tabindex="-1"><a class="header-anchor" href="#栈运行原理" aria-hidden="true">#</a> 栈运行原理</h6><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h4 id="栈帧的内部结构" tabindex="-1"><a class="header-anchor" href="#栈帧的内部结构" aria-hidden="true">#</a> 栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack）（或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的</p><img src="/home/assets/image-20200705205443993-9092410c.png" alt="image-20200705205443993" style="zoom:67%;"><h4 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> 局部变量表</h4><p>局部变量表：Local Variables，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h5 id="关于slot的理解" tabindex="-1"><a class="header-anchor" href="#关于slot的理解" aria-hidden="true">#</a> 关于Slot的理解</h5><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（Long和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 Long和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该<strong>对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p><img src="/home/assets/image-20200705212454445-ea54eee4.png" alt="image-20200705212454445" style="zoom:67%;"><blockquote><p>Slot的重复利用</p></blockquote><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><h5 id="静态变量与局部变量的对比" tabindex="-1"><a class="header-anchor" href="#静态变量与局部变量的对比" aria-hidden="true">#</a> 静态变量与局部变量的对比</h5><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量 <ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h4 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈" aria-hidden="true">#</a> 操作数栈</h4><h5 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h5><p>操作数栈：Operand Stack</p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><img src="/home/assets/image-20200706090618332-0480c4b2.png" alt="image-20200706090618332" style="zoom:67%;"><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存技术" tabindex="-1"><a class="header-anchor" href="#栈顶缓存技术" aria-hidden="true">#</a> 栈顶缓存技术</h5><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><blockquote><p>寄存器：指令更少，执行速度快</p></blockquote><h4 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h4><p>动态链接：Dynamic Linking</p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><img src="/home/assets/image-20200706101251847-8d22e686.png" alt="image-20200706101251847" style="zoom:67%;"><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h5 id="方法调用-解析与分配" tabindex="-1"><a class="header-anchor" href="#方法调用-解析与分配" aria-hidden="true">#</a> 方法调用：解析与分配</h5><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h5 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h5><h6 id="静态链接" tabindex="-1"><a class="header-anchor" href="#静态链接" aria-hidden="true">#</a> 静态链接</h6><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可以确定，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h6 id="动态链接-1" tabindex="-1"><a class="header-anchor" href="#动态链接-1" aria-hidden="true">#</a> 动态链接</h6><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h5 id="绑定机制" tabindex="-1"><a class="header-anchor" href="#绑定机制" aria-hidden="true">#</a> 绑定机制</h5><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h6 id="早期绑定" tabindex="-1"><a class="header-anchor" href="#早期绑定" aria-hidden="true">#</a> 早期绑定</h6><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h6 id="晚期绑定" tabindex="-1"><a class="header-anchor" href="#晚期绑定" aria-hidden="true">#</a> 晚期绑定</h6><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h5 id="虚方法和非虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法和非虚方法" aria-hidden="true">#</a> 虚方法和非虚方法</h5><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h6 id="普通调用指令" tabindex="-1"><a class="header-anchor" href="#普通调用指令" aria-hidden="true">#</a> 普通调用指令：</h6><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h6 id="动态调用指令" tabindex="-1"><a class="header-anchor" href="#动态调用指令" aria-hidden="true">#</a> 动态调用指令：</h6><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h6 id="invokednamic指令" tabindex="-1"><a class="header-anchor" href="#invokednamic指令" aria-hidden="true">#</a> invokednamic指令</h6><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><h5 id="动态类型语言和静态类型语言" tabindex="-1"><a class="header-anchor" href="#动态类型语言和静态类型语言" aria-hidden="true">#</a> 动态类型语言和静态类型语言</h5><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = &quot;mogu blog&quot;; (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = &quot;shkstart&quot;; var name = 10; （运行时才进行检查）</p></blockquote><h5 id="方法重写的本质" tabindex="-1"><a class="header-anchor" href="#方法重写的本质" aria-hidden="true">#</a> 方法重写的本质</h5><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ul><h6 id="illegalaccesserror" tabindex="-1"><a class="header-anchor" href="#illegalaccesserror" aria-hidden="true">#</a> IllegalAccessError</h6><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h5 id="方法的调用-虚方法表" tabindex="-1"><a class="header-anchor" href="#方法的调用-虚方法表" aria-hidden="true">#</a> 方法的调用：虚方法表</h5><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><blockquote><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p></blockquote><h4 id="方法返回地址" tabindex="-1"><a class="header-anchor" href="#方法返回地址" aria-hidden="true">#</a> 方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn(引用类型)。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><img src="/home/assets/image-20200706154554604-f57f1c36.png" alt="image-20200706154554604" style="zoom:67%;"><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h4 id="一些附加信息" tabindex="-1"><a class="header-anchor" href="#一些附加信息" aria-hidden="true">#</a> 一些附加信息</h4><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><p>运行时数据区，是否存在Error(OOM)和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table><h3 id="_3本地方法栈" tabindex="-1"><a class="header-anchor" href="#_3本地方法栈" aria-hidden="true">#</a> 3本地方法栈</h3><h4 id="概念-1" tabindex="-1"><a class="header-anchor" href="#概念-1" aria-hidden="true">#</a> 概念</h4><p>Java虚拟机栈于管理Java方法的调用，而<strong>本地方法栈用于管理本地方法的调用</strong>。</p><p><strong>本地方法栈，也是线程私有的。</strong></p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul><p>本地方法是使用C语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><img src="/home/assets/image-20200706174708418-982d49d9.png" alt="image-20200706174708418" style="zoom:50%;"><h4 id="本地方法接口" tabindex="-1"><a class="header-anchor" href="#本地方法接口" aria-hidden="true">#</a> 本地方法接口</h4><h5 id="什么是本地方法" tabindex="-1"><a class="header-anchor" href="#什么是本地方法" aria-hidden="true">#</a> 什么是本地方法</h5><p>简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern &quot;c&quot; 告知c++编译器去调用一个c的函数。</p><p>&quot;A native method is a Java method whose implementation is provided by non-java code.&quot;（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><blockquote><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p></blockquote><h5 id="为什么使用native-method" tabindex="-1"><a class="header-anchor" href="#为什么使用native-method" aria-hidden="true">#</a> 为什么使用Native Method？</h5><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h6 id="与java外环境的交互" tabindex="-1"><a class="header-anchor" href="#与java外环境的交互" aria-hidden="true">#</a> 与Java外环境的交互</h6><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h6 id="与操作系统的交互" tabindex="-1"><a class="header-anchor" href="#与操作系统的交互" aria-hidden="true">#</a> 与操作系统的交互</h6><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h6 id="sun-s-java" tabindex="-1"><a class="header-anchor" href="#sun-s-java" aria-hidden="true">#</a> Sun&#39;s Java</h6><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p><h5 id="现状" tabindex="-1"><a class="header-anchor" href="#现状" aria-hidden="true">#</a> 现状</h5><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h3 id="_4堆" tabindex="-1"><a class="header-anchor" href="#_4堆" aria-hidden="true">#</a> 4堆</h3><h4 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h4><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><blockquote><p>-Xms10m：堆初始化内存</p><p>-Xmx10m：最大堆内存</p></blockquote><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>事实上：“几乎”所有的对象实例都在这里分配内存。</p><ul><li>因为还有一些对象是在栈上分配的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p><img src="/home/assets/image-20200706201904057-1d6290e2.png" alt="image-20200706201904057" style="zoom:67%;"><h4 id="堆内存细分" tabindex="-1"><a class="header-anchor" href="#堆内存细分" aria-hidden="true">#</a> 堆内存细分</h4><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space永久区 Perm</li></ul><p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间</p><ul><li>Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区 = 新生代 = 年轻代 、 养老区 = 老年区 = 老年代、 永久区 = 永久代</p><img src="/home/assets/image-20200706203835403-e7016772.png" alt="image-20200706203835403" style="zoom:50%;"><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><h4 id="设置堆内存大小与oom" tabindex="-1"><a class="header-anchor" href="#设置堆内存大小与oom" aria-hidden="true">#</a> 设置堆内存大小与OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项&quot;-Xmx&quot;和&quot;-Xms&quot;来进行设置。</p><ul><li>“-Xms&quot;用于表示堆区的起始内存，等价于-xx:InitialHeapSize</li><li>“-Xmx&quot;则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过“-xmx&quot;所指定的最大内存时，将会抛出outofMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是<strong>为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</strong>。</p><p>默认情况下</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/**
 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
 *  -X：是jvm运行参数
 *  ms：memory start
 * -Xmx：用来设置堆空间（年轻代+老年代）的最大内存大小
 */
public class HeapSpaceInitial {
    public static void main(String[] args) {
        // 返回Java虚拟机中的堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机试图使用的最大堆内存
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
        System.out.println(&quot;-Xms:&quot; + initialMemory + &quot;M&quot;);
        System.out.println(&quot;-Xmx:&quot; + maxMemory + &quot;M&quot;);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何查看堆内存的内存分配情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jps  -&gt;  jstat -gc 进程id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="/home/assets/image-20200706205756045-7af81efc.png" alt="image-20200706205756045"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-XX:+PrintGCDetails
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="/home/assets/image-20200706205821919-726d89c7.png" alt="image-20200706205821919" style="zoom:50%;"><h4 id="年轻代与老年代" tabindex="-1"><a class="header-anchor" href="#年轻代与老年代" aria-hidden="true">#</a> 年轻代与老年代</h4><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 <ul><li>生命周期短的，及时回收即可</li></ul></li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><img src="/home/assets/image-20200707075847954-9bff9fd7.png" alt="image-20200707075847954" style="zoom:67%;"><ul><li>Eden：From：to -&gt; 8:1:1</li><li>新生代：老年代 - &gt; 1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项&quot;-Xmn&quot;设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><h5 id="对象分配过程" tabindex="-1"><a class="header-anchor" href="#对象分配过程" aria-hidden="true">#</a> 对象分配过程</h5><p>为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><p>可以设置参数：-Xx:MaxTenuringThreshold= N进行设置</p><p>图例：</p><p>创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作</p><img src="/home/assets/image-20200707084714886-3db92ec4.png" alt="image-20200707084714886" style="zoom:50%;"><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><img src="/home/assets/image-20200707085232646-53873812.png" alt="image-20200707085232646" style="zoom:50%;"><p>继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中</p><img src="/home/assets/image-20200707085737207-53bc674d.png" alt="image-20200707085737207" style="zoom:50%;"><h5 id="幸存区区满" tabindex="-1"><a class="header-anchor" href="#幸存区区满" aria-hidden="true">#</a> 幸存区区满</h5><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><img src="/home/assets/image-20200707091058346-f996302b.png" alt="image-20200707091058346" style="zoom:50%;"><h5 id="常用的调优工具" tabindex="-1"><a class="header-anchor" href="#常用的调优工具" aria-hidden="true">#</a> 常用的调优工具</h5><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控 推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h5 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h5><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h4 id="minor-gc-majorgc、full-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc-majorgc、full-gc" aria-hidden="true">#</a> Minor GC，MajorGC、Full GC</h4><ul><li>Minor GC：新生代的GC</li><li>Major GC：老年代的GC</li><li>Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><blockquote><p>JVM的调优的一个环节，就是垃圾收集，需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</p></blockquote><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/old GC）：只是老年代的圾收集。 <ul><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。 <ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</p><h5 id="minor-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc" aria-hidden="true">#</a> Minor GC</h5><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><h5 id="major-gc" tabindex="-1"><a class="header-anchor" href="#major-gc" aria-hidden="true">#</a> Major GC</h5><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了Major Gc，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h5 id="full-gc" tabindex="-1"><a class="header-anchor" href="#full-gc" aria-hidden="true">#</a> Full GC</h5><p>触发Full GC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h5 id="内存分配策略" tabindex="-1"><a class="header-anchor" href="#内存分配策略" aria-hidden="true">#</a> 内存分配策略</h5><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项-xx:MaxTenuringThreshold来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到Eden <ul><li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象 都是 朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li></ul></li><li>大对象直接分配到老年代 <ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断 <ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。</li></ul></li></ul><p>空间分配担保： -Xx:HandlePromotionFailure</p><ul><li>也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</li></ul><h4 id="tlab" tabindex="-1"><a class="header-anchor" href="#tlab" aria-hidden="true">#</a> TLAB</h4><h5 id="堆空间都是共享的么" tabindex="-1"><a class="header-anchor" href="#堆空间都是共享的么" aria-hidden="true">#</a> 堆空间都是共享的么？</h5><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h5 id="为什么有tlab" tabindex="-1"><a class="header-anchor" href="#为什么有tlab" aria-hidden="true">#</a> 为什么有TLAB？</h5><p>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h5 id="什么是tlab" tabindex="-1"><a class="header-anchor" href="#什么是tlab" aria-hidden="true">#</a> 什么是TLAB</h5><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>几乎所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><img src="/home/assets/image-20200707103547712-0051195d.png" alt="image-20200707103547712" style="zoom:50%;"><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><img src="/home/assets/image-20200707104253530-c012f2e7.png" alt="image-20200707104253530" style="zoom:50%;"><h4 id="堆空间参数设置" tabindex="-1"><a class="header-anchor" href="#堆空间参数设置" aria-hidden="true">#</a> 堆空间参数设置</h4><ul><li>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</li><li>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li><li>-Xms：初始堆空间内存（默认为物理内存的1/64）</li><li>-Xmx：最大堆空间内存（默认为物理内存的1/4）</li><li>-Xmn：设置新生代的大小。（初始值及最大值）</li><li>-XX:NewRatio：配置新生代与老年代在堆结构的占比</li><li>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</li><li>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</li><li>-XX：+PrintGCDetails：输出详细的GC处理日志 <ul><li>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</li></ul></li><li>-XX:HandlePromotionFalilure：是否设置空间分配担保</li></ul><blockquote><p>空间分配担保</p></blockquote><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。 <ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次Full GC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Full Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h4 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h4><h5 id="介绍-1" tabindex="-1"><a class="header-anchor" href="#介绍-1" aria-hidden="true">#</a> 介绍</h5><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><blockquote><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h5 id="参数设置" tabindex="-1"><a class="header-anchor" href="#参数设置" aria-hidden="true">#</a> 参数设置</h5><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis&quot;显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis&quot;查看逃逸分析的筛选结果</li></ul><h5 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h5><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h5 id="栈上分配" tabindex="-1"><a class="header-anchor" href="#栈上分配" aria-hidden="true">#</a> 栈上分配</h5><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><h5 id="同步省略" tabindex="-1"><a class="header-anchor" href="#同步省略" aria-hidden="true">#</a> 同步省略</h5><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫<strong>同步省略，也叫锁消除</strong>。</p><p>例如下面的代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> hellis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hellis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字节码中其实还是有锁的字节码，但是在运行的时候会被优化掉</p><h5 id="分离对象-标量替换" tabindex="-1"><a class="header-anchor" href="#分离对象-标量替换" aria-hidden="true">#</a> 分离对象/标量替换</h5><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 <strong>标量替换为栈上分配提供了很好的基础。</strong></p><h5 id="逃逸分析的不足" tabindex="-1"><a class="header-anchor" href="#逃逸分析的不足" aria-hidden="true">#</a> 逃逸分析的不足</h5><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上(说明hotspot不会栈上分配，但是会标量替换，标量替换不等于与创建对象)。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p><h3 id="_5方法区" tabindex="-1"><a class="header-anchor" href="#_5方法区" aria-hidden="true">#</a> 5方法区</h3><h4 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h4><img src="/home/assets/image-20200708094507624-156f029b.png" alt="image-20200708094507624" style="zoom:50%;"><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><img src="/home/assets/image-20200708094747667-5268bcd5.png" alt="image-20200708094747667" style="zoom:50%;"><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace <ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h4 id="hotspot中方法区的演进" tabindex="-1"><a class="header-anchor" href="#hotspot中方法区的演进" aria-hidden="true">#</a> HotSpot中方法区的演进</h4><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>JDK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p><blockquote><p>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）</p></blockquote><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><img src="/home/assets/image-20200708103055914-79d9345e.png" alt="image-20200708103055914" style="zoom:67%;"><h4 id="设置方法区大小与oom" tabindex="-1"><a class="header-anchor" href="#设置方法区大小与oom" aria-hidden="true">#</a> 设置方法区大小与OOM</h4><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h5 id="jdk7及以前" tabindex="-1"><a class="header-anchor" href="#jdk7及以前" aria-hidden="true">#</a> jdk7及以前</h5><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><h5 id="jdk8以后" tabindex="-1"><a class="header-anchor" href="#jdk8以后" aria-hidden="true">#</a> JDK8以后</h5><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到FullGC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h5 id="如何解决这些oom" tabindex="-1"><a class="header-anchor" href="#如何解决这些oom" aria-hidden="true">#</a> 如何解决这些OOM</h5><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） <ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h4 id="内部结构" tabindex="-1"><a class="header-anchor" href="#内部结构" aria-hidden="true">#</a> 内部结构</h4><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><img src="/home/assets/image-20200708161856504-708f3c51.png" alt="image-20200708161856504" style="zoom:50%;"><blockquote><p>需要注意的是静态变量和字符串常量池8以后放在了堆中，但是他们好像还是算作方法区的一部分，但实际上它使用的是堆空间，而不是本地内存。</p></blockquote><h5 id="类型信息" tabindex="-1"><a class="header-anchor" href="#类型信息" aria-hidden="true">#</a> 类型信息</h5><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h5 id="域信息-字段" tabindex="-1"><a class="header-anchor" href="#域信息-字段" aria-hidden="true">#</a> 域信息（字段）</h5><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h5 id="方法-method-信息" tabindex="-1"><a class="header-anchor" href="#方法-method-信息" aria-hidden="true">#</a> 方法（Method）信息</h5><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）</li></ul><blockquote><p>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></blockquote><h5 id="non-final的类变量-静态变量" tabindex="-1"><a class="header-anchor" href="#non-final的类变量-静态变量" aria-hidden="true">#</a> non-final的类变量（静态变量）</h5><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodAreaTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Order order = new Order();</span>
        <span class="token class-name">Order</span> order <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        order<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h5 id="全局常量" tabindex="-1"><a class="header-anchor" href="#全局常量" aria-hidden="true">#</a> 全局常量</h5><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><h5 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池" aria-hidden="true">#</a> 运行时常量池</h5><p>字节码文件中的常量池运行时，加载到方法区，就成了运行时常量池</p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><img src="/home/assets/image-20200708172357052-dd5286b1.png" alt="image-20200708172357052" style="zoom:67%;"><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><blockquote><p>为什么需要常量池</p></blockquote><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</p><blockquote><p>常量池中有什么</p></blockquote><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><blockquote><p>运行时常量池</p></blockquote><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性（可以增加和删除）。</p><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h4 id="方法区的演进细节" tabindex="-1"><a class="header-anchor" href="#方法区的演进细节" aria-hidden="true">#</a> 方法区的演进细节</h4><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK</th><th>特点</th></tr></thead><tbody><tr><td>JDK1.6及以前</td><td>有永久代，静态变量存储在永久代上</td></tr><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><h4 id="为什么永久代要被元空间替代" tabindex="-1"><a class="header-anchor" href="#为什么永久代要被元空间替代" aria-hidden="true">#</a> 为什么永久代要被元空间替代？</h4><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector&#39;java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。 <ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><blockquote><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p></blockquote><h4 id="stringtable为什么要调整位置" tabindex="-1"><a class="header-anchor" href="#stringtable为什么要调整位置" aria-hidden="true">#</a> StringTable为什么要调整位置</h4><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h4 id="静态变量存放在那里" tabindex="-1"><a class="header-anchor" href="#静态变量存放在那里" aria-hidden="true">#</a> 静态变量存放在那里？</h4><p>静态引用对应的对象实体始终都存在堆空间</p><p>JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中。</p><h4 id="方法区的垃圾回收" tabindex="-1"><a class="header-anchor" href="#方法区的垃圾回收" aria-hidden="true">#</a> 方法区的垃圾回收</h4><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h3 id="对象实例化内存布局与访问定位" tabindex="-1"><a class="header-anchor" href="#对象实例化内存布局与访问定位" aria-hidden="true">#</a> 对象实例化内存布局与访问定位</h3><h4 id="对象实例化" tabindex="-1"><a class="header-anchor" href="#对象实例化" aria-hidden="true">#</a> 对象实例化</h4><blockquote><p>面试题</p></blockquote><ul><li>对象在JVM中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li><li>Java对象头有什么？</li></ul><p>从对象创建的方式 和 步骤开始说</p><img src="/home/assets/image-20200709095356247-fc82e898.png" alt="image-20200709095356247" style="zoom:50%;"><h4 id="对象创建方式" tabindex="-1"><a class="header-anchor" href="#对象创建方式" aria-hidden="true">#</a> 对象创建方式</h4><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口</li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h4 id="创建对象的步骤" tabindex="-1"><a class="header-anchor" href="#创建对象的步骤" aria-hidden="true">#</a> 创建对象的步骤</h4><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h5 id="判断对象对应的类是否加载、链接、初始化" tabindex="-1"><a class="header-anchor" href="#判断对象对应的类是否加载、链接、初始化" aria-hidden="true">#</a> 判断对象对应的类是否加载、链接、初始化</h5><p>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><h5 id="为对象分配内存" tabindex="-1"><a class="header-anchor" href="#为对象分配内存" aria-hidden="true">#</a> 为对象分配内存</h5><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞</li><li>如果内存不规整 <ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</p><p>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</p><p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</p><p>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h5 id="处理并发问题" tabindex="-1"><a class="header-anchor" href="#处理并发问题" aria-hidden="true">#</a> 处理并发问题</h5><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制） <ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><h5 id="初始化分配到的内存" tabindex="-1"><a class="header-anchor" href="#初始化分配到的内存" aria-hidden="true">#</a> 初始化分配到的内存</h5><ul><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li></ul><h5 id="设置对象的对象头" tabindex="-1"><a class="header-anchor" href="#设置对象的对象头" aria-hidden="true">#</a> 设置对象的对象头</h5><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h5 id="执行init方法进行初始化" tabindex="-1"><a class="header-anchor" href="#执行init方法进行初始化" aria-hidden="true">#</a> 执行init方法进行初始化</h5><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><h4 id="对象内存布局" tabindex="-1"><a class="header-anchor" href="#对象内存布局" aria-hidden="true">#</a> 对象内存布局</h4><img src="/home/assets/image-20200709151033237-c2193a64.png" alt="image-20200709151033237" style="zoom:50%;"><h5 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头" aria-hidden="true">#</a> 对象头</h5><p>对象头包含了两部分，分别是 运行时元数据（Mark Word）和 类型指针</p><blockquote><p>如果是数组，还需要记录数组的长度</p></blockquote><p>运行时元数据</p><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><p>类型指针</p><p>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p><h5 id="实例数据-instance-data" tabindex="-1"><a class="header-anchor" href="#实例数据-instance-data" aria-hidden="true">#</a> 实例数据（Instance Data）</h5><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)</p><h5 id="对齐填充" tabindex="-1"><a class="header-anchor" href="#对齐填充" aria-hidden="true">#</a> 对齐填充</h5><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><img src="/home/assets/image-20200709152801713-414a2a64.png" alt="image-20200709152801713" style="zoom:50%;"><h4 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位" aria-hidden="true">#</a> 对象的访问定位</h4><p>两种方式</p><h5 id="句柄访问" tabindex="-1"><a class="header-anchor" href="#句柄访问" aria-hidden="true">#</a> 句柄访问</h5><img src="/home/assets/image-20200709164342002-dfd3f0a2.png" alt="image-20200709164342002" style="zoom:50%;"><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><blockquote><p>优点</p></blockquote><p>reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h5 id="直接指针-hotspot采用" tabindex="-1"><a class="header-anchor" href="#直接指针-hotspot采用" aria-hidden="true">#</a> 直接指针（HotSpot采用）</h5><img src="/home/assets/image-20200709164350466-77b625f6.png" alt="image-20200709164350466" style="zoom:50%;"><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h3 id="直接内存direct-memory" tabindex="-1"><a class="header-anchor" href="#直接内存direct-memory" aria-hidden="true">#</a> 直接内存Direct Memory</h3><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>使用下列代码，直接分配本地内存空间</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int BUFFER = 1024*1024*1024; // 1GB
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="非直接缓存区和缓存区" tabindex="-1"><a class="header-anchor" href="#非直接缓存区和缓存区" aria-hidden="true">#</a> 非直接缓存区和缓存区</h4><p>原来采用BIO的架构，我们需要从用户态切换成内核态</p><img src="/home/assets/image-20200709170907611-d18d5fe4.png" alt="image-20200709170907611" style="zoom:50%;"><p>NIO的方式使用了缓存区的概念，不需要切换，直接使用内存</p><h4 id="存在的问题" tabindex="-1"><a class="header-anchor" href="#存在的问题" aria-hidden="true">#</a> 存在的问题</h4><p>也可能导致outofMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 缺点</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值-xmx参数值一致</p><img src="/home/assets/image-20200709230647277-ca14cdfd.png" alt="image-20200709230647277" style="zoom:50%;"><h2 id="三、执行引擎" tabindex="-1"><a class="header-anchor" href="#三、执行引擎" aria-hidden="true">#</a> 三、执行引擎</h2><h3 id="执行引擎概述" tabindex="-1"><a class="header-anchor" href="#执行引擎概述" aria-hidden="true">#</a> 执行引擎概述</h3><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><img src="/home/assets/image-20200710080707873-5f9826d6.png" alt="image-20200710080707873" style="zoom:50%;"><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p><img src="/home/assets/image-20200710081118053-51d032e8.png" alt="image-20200710081118053" style="zoom:50%;"><p>那么，如果想要让一个Java程序运行起来，需要执行引擎（Execution Engine）将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><h4 id="执行引擎的工作流程" tabindex="-1"><a class="header-anchor" href="#执行引擎的工作流程" aria-hidden="true">#</a> 执行引擎的工作流程</h4><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p>从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h3 id="java代码编译和执行过程" tabindex="-1"><a class="header-anchor" href="#java代码编译和执行过程" aria-hidden="true">#</a> Java代码编译和执行过程</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><ul><li>前面橙色部分是生成字节码文件的过程，和JVM无关</li><li>后面蓝色和绿色才是JVM需要考虑的过程</li></ul><img src="/home/assets/image-20200710082141643-b86b8e6a.png" alt="image-20200710082141643" style="zoom:50%;"><p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p><img src="/home/assets/image-20200710082433146-ba698b57.png" alt="image-20200710082433146" style="zoom:50%;"><p>Java字节码的执行是由JVM执行引擎来完成，流程图 如下所示</p><img src="/home/assets/image-20200710083036258-a2c247b7.png" alt="image-20200710083036258" style="zoom:50%;"><p>我们用一个总的图，来说说 解释器和编译器</p><img src="/home/assets/image-20200710083656277-90b3792b.png" alt="image-20200710083656277" style="zoom:50%;"><h4 id="解释器-interpreter" tabindex="-1"><a class="header-anchor" href="#解释器-interpreter" aria-hidden="true">#</a> 解释器（Interpreter）</h4><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><h4 id="jit编译器" tabindex="-1"><a class="header-anchor" href="#jit编译器" aria-hidden="true">#</a> JIT编译器</h4><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码（字节码）直接编译成和本地机器平台相关的机器语言。</p><h4 id="为什么java是半编译半解释型语言" tabindex="-1"><a class="header-anchor" href="#为什么java是半编译半解释型语言" aria-hidden="true">#</a> 为什么Java是半编译半解释型语言</h4><p>JDK1.e时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</p><h3 id="机器码、指令、汇编语言" tabindex="-1"><a class="header-anchor" href="#机器码、指令、汇编语言" aria-hidden="true">#</a> 机器码、指令、汇编语言</h3><h4 id="机器码" tabindex="-1"><a class="header-anchor" href="#机器码" aria-hidden="true">#</a> 机器码</h4><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</p><h4 id="指令" tabindex="-1"><a class="header-anchor" href="#指令" aria-hidden="true">#</a> 指令</h4><p>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p><h4 id="指令集" tabindex="-1"><a class="header-anchor" href="#指令集" aria-hidden="true">#</a> 指令集</h4><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h4 id="汇编语言" tabindex="-1"><a class="header-anchor" href="#汇编语言" aria-hidden="true">#</a> 汇编语言</h4><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><blockquote><p>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</p></blockquote><h4 id="高级语言" tabindex="-1"><a class="header-anchor" href="#高级语言" aria-hidden="true">#</a> 高级语言</h4><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。</p><p>高级语言比机器语言、汇编语言更接近人的语言当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p><img src="/home/assets/image-20200710085323733-18cf54ec.png" alt="image-20200710085323733" style="zoom:50%;"><p>高级语言也不是直接翻译成 机器指令，而是翻译成汇编语言吗，如下面说的C和C++</p><h4 id="字节码" tabindex="-1"><a class="header-anchor" href="#字节码" aria-hidden="true">#</a> 字节码</h4><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码典型的应用为：Java bytecode</li></ul><h3 id="解释器" tabindex="-1"><a class="header-anchor" href="#解释器" aria-hidden="true">#</a> 解释器</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h4 id="解释器分类" tabindex="-1"><a class="header-anchor" href="#解释器分类" aria-hidden="true">#</a> 解释器分类</h4><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><p>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</p><p>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h4 id="现状-1" tabindex="-1"><a class="header-anchor" href="#现状-1" aria-hidden="true">#</a> 现状</h4><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。</p><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h3 id="jit编译器-1" tabindex="-1"><a class="header-anchor" href="#jit编译器-1" aria-hidden="true">#</a> JIT编译器</h3><h4 id="java代码的执行分类" tabindex="-1"><a class="header-anchor" href="#java代码的执行分类" aria-hidden="true">#</a> Java代码的执行分类</h4><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p><blockquote><p>问题来了</p></blockquote><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</p><p>在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h4 id="hotspot-jvm执行方式" tabindex="-1"><a class="header-anchor" href="#hotspot-jvm执行方式" aria-hidden="true">#</a> HotSpot JVM执行方式</h4><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h4 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h4><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态(刚启动)。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><img src="/home/assets/image-20200710095417462-ba8b640e.png" alt="image-20200710095417462" style="zoom:67%;"><h4 id="概念解释" tabindex="-1"><a class="header-anchor" href="#概念解释" aria-hidden="true">#</a> 概念解释</h4><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程；也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）</li><li>把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。</li></ul><p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p><p>JIT编译器：HotSpot VM的C1、C2编译器。</p><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p><h4 id="热点探测技术" tabindex="-1"><a class="header-anchor" href="#热点探测技术" aria-hidden="true">#</a> 热点探测技术</h4><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。</p><p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。采用基于计数器的热点探测，HotSpot V将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h5 id="方法调用计数器" tabindex="-1"><a class="header-anchor" href="#方法调用计数器" aria-hidden="true">#</a> 方法调用计数器</h5><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><img src="/home/assets/image-20200710101829934-eedfb7d2.png" alt="image-20200710101829934" style="zoom:67%;"><h5 id="热点衰减" tabindex="-1"><a class="header-anchor" href="#热点衰减" aria-hidden="true">#</a> 热点衰减</h5><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）</p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p><h5 id="回边计数器" tabindex="-1"><a class="header-anchor" href="#回边计数器" aria-hidden="true">#</a> 回边计数器</h5><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="/home/assets/image-20200710103103869-24640d4e.png" alt="image-20200710103103869" style="zoom:67%;"><h4 id="hotspotvm-设置程序执行方法" tabindex="-1"><a class="header-anchor" href="#hotspotvm-设置程序执行方法" aria-hidden="true">#</a> HotSpotVM 设置程序执行方法</h4><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h4 id="hotspotvm中-jit-分类" tabindex="-1"><a class="header-anchor" href="#hotspotvm中-jit-分类" aria-hidden="true">#</a> HotSpotVM中 JIT 分类</h4><p>JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器； <ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。 <ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h5 id="c1-和-c2编译器不同的优化策略" tabindex="-1"><a class="header-anchor" href="#c1-和-c2编译器不同的优化策略" aria-hidden="true">#</a> C1 和 C2编译器不同的优化策略</h5><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h5 id="分层编译策略" tabindex="-1"><a class="header-anchor" href="#分层编译策略" aria-hidden="true">#</a> 分层编译策略</h5><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server&quot;时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><blockquote><p>总结</p></blockquote><ul><li>一般来讲，JIT编译出来的机器码性能比解释器搞</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="aot编译器" tabindex="-1"><a class="header-anchor" href="#aot编译器" aria-hidden="true">#</a> AOT编译器</h3><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul><blockquote><p>写到最后</p></blockquote><ul><li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器</li><li>编译效果短短几年时间就追评了G2编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 1743760069@qq.com">liushun-ing</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: 1743760069@qq.com">liushun</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/home/master/jvm/1.html" class="" aria-label="JVM与Java体系结构"><!--[--><!--]--> JVM与Java体系结构 <!--[--><!--]--></a></span><span class="next"><a href="/home/master/jvm/3.html" class="" aria-label="StringTable"><!--[--><!--]--> StringTable <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/home/assets/app-617a181d.js" defer></script>
  </body>
</html>
